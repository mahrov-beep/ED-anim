// <auto-generated>
// This code was auto-generated by a tool, every time
// the tool executes this code will be reset.
//
// If you need to extend the classes generated to add
// fields or methods to them, please create partial
// declarations in another file.
// </auto-generated>
#pragma warning disable 0109
#pragma warning disable 1591


namespace Quantum {
  using System;
  using System.Collections.Generic;
  using System.ComponentModel;
  using Photon.Deterministic;
  using Quantum;
  using Quantum.Core;
  using Quantum.Collections;
  using Quantum.Inspector;
  using Quantum.Physics2D;
  using Quantum.Physics3D;
  using Byte = System.Byte;
  using SByte = System.SByte;
  using Int16 = System.Int16;
  using UInt16 = System.UInt16;
  using Int32 = System.Int32;
  using UInt32 = System.UInt32;
  using Int64 = System.Int64;
  using UInt64 = System.UInt64;
  using Boolean = System.Boolean;
  using String = System.String;
  using Object = System.Object;
  using FlagsAttribute = System.FlagsAttribute;
  using SerializableAttribute = System.SerializableAttribute;
  using MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute;
  using MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions;
  using FieldOffsetAttribute = System.Runtime.InteropServices.FieldOffsetAttribute;
  using StructLayoutAttribute = System.Runtime.InteropServices.StructLayoutAttribute;
  using LayoutKind = System.Runtime.InteropServices.LayoutKind;
  #if QUANTUM_UNITY //;
  using TooltipAttribute = UnityEngine.TooltipAttribute;
  using HeaderAttribute = UnityEngine.HeaderAttribute;
  using SpaceAttribute = UnityEngine.SpaceAttribute;
  using RangeAttribute = UnityEngine.RangeAttribute;
  using HideInInspectorAttribute = UnityEngine.HideInInspector;
  using PreserveAttribute = UnityEngine.Scripting.PreserveAttribute;
  using FormerlySerializedAsAttribute = UnityEngine.Serialization.FormerlySerializedAsAttribute;
  using MovedFromAttribute = UnityEngine.Scripting.APIUpdating.MovedFromAttribute;
  using CreateAssetMenu = UnityEngine.CreateAssetMenuAttribute;
  using RuntimeInitializeOnLoadMethodAttribute = UnityEngine.RuntimeInitializeOnLoadMethodAttribute;
  #endif //;
  
  public enum AbilityAvailabilityType : int {
    Always,
  }
  public enum CharacterStates : int {
    Invalid = 0,
    Idle = 1,
    Walk = 2,
    Roll = 4,
    Dead = 5,
    Sprint = 6,
    Knocked = 7,
    Reviving = 8,
    CrouchIdle = 9,
    CrouchMove = 10,
    Healing = 11,
    KnifeAttack = 12,
    Jump = 13,
  }
  public enum EAttributeType : byte {
    None = 0,
    PercentBoost_MoveSpeed = 32,
    PercentBoost_SprintSpeed = 33,
    PercentBoost_ShootingSpread = 34,
    PercentBoost_ShootingSpreadInMovement = 35,
    PercentBoost_MaxAmmo = 36,
    PercentBoost_ProjectileSpeed = 37,
    PercentBoost_WeaponReloadDuration = 39,
    PercentBoost_WeaponTriggerDistance = 40,
    PercentBoost_WeaponDamage = 41,
    PercentBoost_WeaponDistanceDamage = 42,
    PercentBoost_WeaponCameraOffset = 44,
    PercentBoost_WeaponTriggerDistanceInAim = 45,
    PercentBoost_CameraOffset = 50,
    PercentBoost_FOWVisionDistance = 51,
    PercentBoost_MinimapRadius = 52,
    PercentBoost_CritChance = 53,
    PercentBoost_CritDamage = 54,
    PercentBoost_RecoilX = 55,
    PercentBoost_RecoilY = 56,
    PercentBoost_ShotImpulse = 57,
    PercentBoost_PreShotAiming = 58,
    PercentBoost_MyStepCueDistance = 60,
    PercentBoost_WeaponShotSoundRange = 61,
    PercentBoost_JumpImpulse = 62,
    AdditiveBoost_MaxWeight = 70,
    AdditiveBoost_LoadoutWidth = 71,
    AdditiveBoost_LoadoutHeight = 72,
    Set_Immunity = 101,
    Set_ForceMoveForward = 102,
    Set_LockRotation = 103,
    Set_ForceVisibleInInvisibilityZone = 104,
    Set_LockMovement = 105,
    Set_Blind = 106,
    Set_ForceVisibleOnMap = 107,
    Set_ReconDetected = 108,
    PercentBoost_ResistAllDamage = 130,
    PercentBoost_ResistBullet = 131,
    PercentBoost_ResistFire = 132,
    PercentBoost_ResistExplosion = 133,
    PercentBoost_ResistMelee = 134,
    PercentBoost_ResistZone = 135,
    PercentBoost_AudioDistance = 160,
    PercentBoost_AudioVolume = 161,
  }
  public enum EDamageType : byte {
    None = 0,
    Bullet = 1,
    Melee = 2,
    Explosion = 5,
    Fire = 10,
    DamageZone = 11,
  }
  public enum EGameStates : int {
    None,
    Presentation,
    Game,
    BeforeExit,
    Exited,
  }
  public enum EKCCCollisionSource : byte {
    None = 0,
    Entity = 1,
    Collider = 2,
  }
  public enum EKCCIgnoreSource : byte {
    None = 0,
    Entity = 1,
    Collider = 2,
  }
  public enum EKCCProcessorSource : byte {
    None = 0,
    Modifier = 1,
    StaticCollider = 2,
    EntityCollider = 3,
  }
  public enum EModifierAppliance : byte {
    None = 0,
    OneTime = 1,
    Continuous = 2,
    Temporary = 3,
  }
  public enum EModifierOperation : byte {
    None = 0,
    Add = 1,
    Subtract = 2,
  }
  public enum HealthAttributeAppliance : byte {
    None = 0,
    OneTime = 1,
    Continuous = 2,
    Temporary = 3,
  }
  public enum HealthAttributeOperation : byte {
    None = 0,
    Heal = 1,
    Damage = 2,
    IncreaseHealth = 3,
    DecreaseHealth = 4,
    IncreaseMaxHealth = 5,
    DecreaseMaxHealth = 6,
  }
  public enum PerceptionType : int {
    None = 0,
    Seen = 1,
    Heard = 2,
    Both = 3,
  }
  public enum SafeChangeKind : int {
    Added = 0,
    Removed = 1,
    Moved = 2,
  }
  public enum WeaponSlot : int {
    None,
    Primary,
    Secondary,
    Melee,
  }
  [System.FlagsAttribute()]
  public enum InputButtons : int {
    SecondaryAction = 1 << 0,
    AimButton = 1 << 1,
    SprintButton = 1 << 2,
  }
  public static unsafe partial class FlagsExtensions {
    public static Boolean IsFlagSet(this InputButtons self, InputButtons flag) {
      return (self & flag) == flag;
    }
    public static InputButtons SetFlag(this InputButtons self, InputButtons flag) {
      return self | flag;
    }
    public static InputButtons ClearFlag(this InputButtons self, InputButtons flag) {
      return self & ~flag;
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet128 {
    public const Int32 SIZE = 16;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public fixed UInt64 Bits[2];
    public const Int32 BitsSize = 128;
    public readonly Int32 Length {
      get {
        return 128;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet128*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->Bits, 128, 64, printer);
      printer.ScopeEnd();
    }
    public static BitSet128 FromArray(UInt64[] values) {
      Assert.Always(2 == values.Length, "Invalid array size", values.Length);
      BitSet128 result = default;
      for (int i = 0; i < 2; ++i) {
        result.Bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 128);
      fixed (UInt64* p = Bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 128);
      fixed (UInt64* p = Bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = Bits) Native.Utils.Clear(p, 16);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = Bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly Int32 GetSetCount() {
      fixed (UInt64* p = Bits) {
        int result = 0;
        result += Maths.CountSetBits(p[0]);
        result += Maths.CountSetBits(p[1]);
        return result;
      }
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly Boolean IsAnySet() {
      fixed (UInt64* p = Bits) {
        if (p[0] != 0) return true;
        if (p[1] != 0) return true;
        return false;
      }
    }
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 4463;
        fixed (UInt64* p = Bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 2);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet128*)ptr;
        serializer.Stream.SerializeBuffer(&p->Bits[0], 2);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet2048 {
    public const Int32 SIZE = 256;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public fixed UInt64 Bits[32];
    public const Int32 BitsSize = 2048;
    public readonly Int32 Length {
      get {
        return 2048;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet2048*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->Bits, 2048, 64, printer);
      printer.ScopeEnd();
    }
    public static BitSet2048 FromArray(UInt64[] values) {
      Assert.Always(32 == values.Length, "Invalid array size", values.Length);
      BitSet2048 result = default;
      for (int i = 0; i < 32; ++i) {
        result.Bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 2048);
      fixed (UInt64* p = Bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 2048);
      fixed (UInt64* p = Bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = Bits) Native.Utils.Clear(p, 256);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = Bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly Int32 GetSetCount() {
      fixed (UInt64* p = Bits) {
        int result = 0;
        for (int i = 0; i < 32; ++i) {
          result += Maths.CountSetBits(p[i]);
        }
        return result;
      }
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly Boolean IsAnySet() {
      fixed (UInt64* p = Bits) {
        for (int i = 0; i < 32; ++i) {
          if (p[i] != 0) return true;
        }
        return false;
      }
    }
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 3319;
        fixed (UInt64* p = Bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 32);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet2048*)ptr;
        serializer.Stream.SerializeBuffer(&p->Bits[0], 32);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet256 {
    public const Int32 SIZE = 32;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public fixed UInt64 Bits[4];
    public const Int32 BitsSize = 256;
    public readonly Int32 Length {
      get {
        return 256;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet256*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->Bits, 256, 64, printer);
      printer.ScopeEnd();
    }
    public static BitSet256 FromArray(UInt64[] values) {
      Assert.Always(4 == values.Length, "Invalid array size", values.Length);
      BitSet256 result = default;
      for (int i = 0; i < 4; ++i) {
        result.Bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 256);
      fixed (UInt64* p = Bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 256);
      fixed (UInt64* p = Bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = Bits) Native.Utils.Clear(p, 32);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = Bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly Int32 GetSetCount() {
      fixed (UInt64* p = Bits) {
        int result = 0;
        result += Maths.CountSetBits(p[0]);
        result += Maths.CountSetBits(p[1]);
        result += Maths.CountSetBits(p[2]);
        result += Maths.CountSetBits(p[3]);
        return result;
      }
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly Boolean IsAnySet() {
      fixed (UInt64* p = Bits) {
        if (p[0] != 0) return true;
        if (p[1] != 0) return true;
        if (p[2] != 0) return true;
        if (p[3] != 0) return true;
        return false;
      }
    }
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 14057;
        fixed (UInt64* p = Bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 4);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet256*)ptr;
        serializer.Stream.SerializeBuffer(&p->Bits[0], 4);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet4096 {
    public const Int32 SIZE = 512;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public fixed UInt64 Bits[64];
    public const Int32 BitsSize = 4096;
    public readonly Int32 Length {
      get {
        return 4096;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet4096*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->Bits, 4096, 64, printer);
      printer.ScopeEnd();
    }
    public static BitSet4096 FromArray(UInt64[] values) {
      Assert.Always(64 == values.Length, "Invalid array size", values.Length);
      BitSet4096 result = default;
      for (int i = 0; i < 64; ++i) {
        result.Bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 4096);
      fixed (UInt64* p = Bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 4096);
      fixed (UInt64* p = Bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = Bits) Native.Utils.Clear(p, 512);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = Bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly Int32 GetSetCount() {
      fixed (UInt64* p = Bits) {
        int result = 0;
        for (int i = 0; i < 64; ++i) {
          result += Maths.CountSetBits(p[i]);
        }
        return result;
      }
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly Boolean IsAnySet() {
      fixed (UInt64* p = Bits) {
        for (int i = 0; i < 64; ++i) {
          if (p[i] != 0) return true;
        }
        return false;
      }
    }
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 1433;
        fixed (UInt64* p = Bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 64);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet4096*)ptr;
        serializer.Stream.SerializeBuffer(&p->Bits[0], 64);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet512 {
    public const Int32 SIZE = 64;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public fixed UInt64 Bits[8];
    public const Int32 BitsSize = 512;
    public readonly Int32 Length {
      get {
        return 512;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet512*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->Bits, 512, 64, printer);
      printer.ScopeEnd();
    }
    public static BitSet512 FromArray(UInt64[] values) {
      Assert.Always(8 == values.Length, "Invalid array size", values.Length);
      BitSet512 result = default;
      for (int i = 0; i < 8; ++i) {
        result.Bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 512);
      fixed (UInt64* p = Bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 512);
      fixed (UInt64* p = Bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = Bits) Native.Utils.Clear(p, 64);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = Bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly Int32 GetSetCount() {
      fixed (UInt64* p = Bits) {
        int result = 0;
        for (int i = 0; i < 8; ++i) {
          result += Maths.CountSetBits(p[i]);
        }
        return result;
      }
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly Boolean IsAnySet() {
      fixed (UInt64* p = Bits) {
        for (int i = 0; i < 8; ++i) {
          if (p[i] != 0) return true;
        }
        return false;
      }
    }
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 17491;
        fixed (UInt64* p = Bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 8);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet512*)ptr;
        serializer.Stream.SerializeBuffer(&p->Bits[0], 8);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet6 {
    public const Int32 SIZE = 8;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public fixed UInt64 Bits[1];
    public const Int32 BitsSize = 6;
    public readonly Int32 Length {
      get {
        return 6;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet6*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->Bits, 6, 64, printer);
      printer.ScopeEnd();
    }
    public static BitSet6 FromArray(UInt64[] values) {
      Assert.Always(1 == values.Length, "Invalid array size", values.Length);
      BitSet6 result = default;
      for (int i = 0; i < 1; ++i) {
        result.Bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 6);
      fixed (UInt64* p = Bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 6);
      fixed (UInt64* p = Bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = Bits) Native.Utils.Clear(p, 8);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = Bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly Int32 GetSetCount() {
      fixed (UInt64* p = Bits) {
        int result = 0;
        result += Maths.CountSetBits(p[0] & 0x3FUL);
        return result;
      }
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly Boolean IsAnySet() {
      fixed (UInt64* p = Bits) {
        if ((p[0] & 0x3FUL) != 0) return true;
        return false;
      }
    }
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 13669;
        fixed (UInt64* p = Bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 1);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet6*)ptr;
        serializer.Stream.SerializeBuffer(&p->Bits[0], 1);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  [System.SerializableAttribute()]
  public unsafe partial struct QString32 : IQString, System.IEquatable<QString32> {
    public const Int32 SIZE = 32;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    public UInt16 ByteCount;
    [FieldOffset(2)]
    [FixedBufferDynamicLength("ByteCount")]
    public fixed Byte Bytes[30];
    public const int MaxByteCount = 30;
    public QString32(String str) {
      QString.ConstructFrom(str, MaxByteCount, out this);
    }
    public readonly System.Int32 Length {
      get {
        return QString.GetLength(in this);
      }
    }
    public readonly override System.String ToString() {
      return QString.GetString(in this);
    }
    public static Boolean CanHold(String str) {
      return QString.CanHold(str, MaxByteCount);
    }
    Int32 IQString.CompareOrdinal(byte* bytes, UInt16 byteCount) {
      return QString.CompareOrdinal(in this, bytes, byteCount);
    }
    public readonly Int32 CompareOrdinal(String str) {
      return QString.CompareOrdinal(in this, str);
    }
    public static implicit operator QString32(String str) {
      return new QString32(str);
    }
    public static implicit operator String(QString32 str) {
      return str.ToString();
    }
    public override readonly Boolean Equals(Object obj) {
      return QString.AreEqual(in this, obj);
    }
    public readonly Boolean Equals(QString32 str) {
      return QString.CompareOrdinal(in this, str.Bytes, str.ByteCount) == 0;
    }
    public readonly Boolean Equals<T>(in T str)
      where T : unmanaged, IQString {
      return QString.CompareOrdinal(in this, in str) == 0;
    }
    public readonly Int32 CompareOrdinal<T>(in T str)
      where T : unmanaged, IQString {
      return QString.CompareOrdinal(in this, in str);
    }
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 12713;
        hash = hash * 31 + ByteCount.GetHashCode();
        fixed (Byte* p = Bytes) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, this.ByteCount);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (QString32*)ptr;
        serializer.Stream.Serialize(&p->ByteCount);
        Assert.Always(p->ByteCount <= 30, p->ByteCount);
        serializer.Stream.SerializeBuffer(&p->Bytes[0], p->ByteCount);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct ActiveAbilityInfo {
    public const Int32 SIZE = 88;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(8)]
    [ExcludeFromPrototype()]
    public FPVector3 CastDirectionNormalized;
    [FieldOffset(56)]
    [ExcludeFromPrototype()]
    public FPQuaternion CastRotation;
    [FieldOffset(32)]
    [ExcludeFromPrototype()]
    public FPVector3 CastVelocity;
    [FieldOffset(0)]
    public EntityRef AbilityEffectRef;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 2017;
        hash = hash * 31 + CastDirectionNormalized.GetHashCode();
        hash = hash * 31 + CastRotation.GetHashCode();
        hash = hash * 31 + CastVelocity.GetHashCode();
        hash = hash * 31 + AbilityEffectRef.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (ActiveAbilityInfo*)ptr;
        EntityRef.Serialize(&p->AbilityEffectRef, serializer);
        FPVector3.Serialize(&p->CastDirectionNormalized, serializer);
        FPVector3.Serialize(&p->CastVelocity, serializer);
        FPQuaternion.Serialize(&p->CastRotation, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct AttributeData {
    public const Int32 SIZE = 24;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(16)]
    public FP InitialValue;
    [FieldOffset(8)]
    [HideInInspector()]
    public FP CurrentValue;
    [FieldOffset(0)]
    public QListPtr<AttributeModifier> Modifiers;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 17497;
        hash = hash * 31 + InitialValue.GetHashCode();
        hash = hash * 31 + CurrentValue.GetHashCode();
        hash = hash * 31 + Modifiers.GetHashCode();
        return hash;
      }
    }
    public void ClearPointers(FrameBase f, EntityRef entity) {
      Modifiers = default;
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (AttributeData*)ptr;
        QList.Serialize(&p->Modifiers, serializer, Statics.SerializeAttributeModifier);
        FP.Serialize(&p->CurrentValue, serializer);
        FP.Serialize(&p->InitialValue, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct AttributeModifier {
    public const Int32 SIZE = 40;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(1)]
    public EModifierAppliance ModifierAppliance;
    [FieldOffset(2)]
    public EModifierOperation ModifierOperation;
    [FieldOffset(8)]
    public FP Amount;
    [FieldOffset(0)]
    public EAttributeType AmountMultiplier;
    [FieldOffset(16)]
    public FP Duration;
    [FieldOffset(24)]
    [HideInInspector()]
    public FP Timer;
    [FieldOffset(32)]
    [HideInInspector()]
    public FP TotalAppliedValue;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 14867;
        hash = hash * 31 + (Byte)ModifierAppliance;
        hash = hash * 31 + (Byte)ModifierOperation;
        hash = hash * 31 + Amount.GetHashCode();
        hash = hash * 31 + (Byte)AmountMultiplier;
        hash = hash * 31 + Duration.GetHashCode();
        hash = hash * 31 + Timer.GetHashCode();
        hash = hash * 31 + TotalAppliedValue.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (AttributeModifier*)ptr;
        serializer.Stream.Serialize((Byte*)&p->AmountMultiplier);
        serializer.Stream.Serialize((Byte*)&p->ModifierAppliance);
        serializer.Stream.Serialize((Byte*)&p->ModifierOperation);
        FP.Serialize(&p->Amount, serializer);
        FP.Serialize(&p->Duration, serializer);
        FP.Serialize(&p->Timer, serializer);
        FP.Serialize(&p->TotalAppliedValue, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BotIntent {
    public const Int32 SIZE = 32;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public EntityRef AttackTarget;
    [FieldOffset(8)]
    public FPVector3 MovementTarget;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 6619;
        hash = hash * 31 + AttackTarget.GetHashCode();
        hash = hash * 31 + MovementTarget.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BotIntent*)ptr;
        EntityRef.Serialize(&p->AttackTarget, serializer);
        FPVector3.Serialize(&p->MovementTarget, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct CircleData {
    public const Int32 SIZE = 72;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(16)]
    public FPVector3 Center;
    [FieldOffset(8)]
    public FP Radius;
    [FieldOffset(40)]
    public FPQuaternion Rotation;
    [FieldOffset(0)]
    public QBoolean Wire;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 13931;
        hash = hash * 31 + Center.GetHashCode();
        hash = hash * 31 + Radius.GetHashCode();
        hash = hash * 31 + Rotation.GetHashCode();
        hash = hash * 31 + Wire.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (CircleData*)ptr;
        QBoolean.Serialize(&p->Wire, serializer);
        FP.Serialize(&p->Radius, serializer);
        FPVector3.Serialize(&p->Center, serializer);
        FPQuaternion.Serialize(&p->Rotation, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct CountdownTimer {
    public const Int32 SIZE = 24;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public QBoolean IsStarted;
    [FieldOffset(8)]
    public FP StartTime;
    [FieldOffset(16)]
    public FP TimeLeftRaw;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 8641;
        hash = hash * 31 + IsStarted.GetHashCode();
        hash = hash * 31 + StartTime.GetHashCode();
        hash = hash * 31 + TimeLeftRaw.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (CountdownTimer*)ptr;
        QBoolean.Serialize(&p->IsStarted, serializer);
        FP.Serialize(&p->StartTime, serializer);
        FP.Serialize(&p->TimeLeftRaw, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct FPBoostedMultiplier {
    public const Int32 SIZE = 8;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public FP AdditiveMultiplierMinus1;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 1321;
        hash = hash * 31 + AdditiveMultiplierMinus1.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (FPBoostedMultiplier*)ptr;
        FP.Serialize(&p->AdditiveMultiplierMinus1, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct FPBoostedValue {
    public const Int32 SIZE = 24;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(16)]
    public FP BaseValue;
    [FieldOffset(8)]
    public FP AdditiveValue;
    [FieldOffset(0)]
    public FP AdditiveMultiplierMinus1;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 18251;
        hash = hash * 31 + BaseValue.GetHashCode();
        hash = hash * 31 + AdditiveValue.GetHashCode();
        hash = hash * 31 + AdditiveMultiplierMinus1.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (FPBoostedValue*)ptr;
        FP.Serialize(&p->AdditiveMultiplierMinus1, serializer);
        FP.Serialize(&p->AdditiveValue, serializer);
        FP.Serialize(&p->BaseValue, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct FPYawPitchRoll {
    public const Int32 SIZE = 24;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(16)]
    public FP Yaw;
    [FieldOffset(0)]
    public FP Pitch;
    [FieldOffset(8)]
    public FP Roll;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 17597;
        hash = hash * 31 + Yaw.GetHashCode();
        hash = hash * 31 + Pitch.GetHashCode();
        hash = hash * 31 + Roll.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (FPYawPitchRoll*)ptr;
        FP.Serialize(&p->Pitch, serializer);
        FP.Serialize(&p->Roll, serializer);
        FP.Serialize(&p->Yaw, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct GlobalVisibilityData {
    public const Int32 SIZE = 4;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    public QHashSetPtr<EntityRef> visibleUnits;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 3467;
        hash = hash * 31 + visibleUnits.GetHashCode();
        return hash;
      }
    }
    public void ClearPointers(FrameBase f, EntityRef entity) {
      visibleUnits = default;
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (GlobalVisibilityData*)ptr;
        QHashSet.Serialize(&p->visibleUnits, serializer, Statics.SerializeEntityRef);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  [Sirenix.OdinInspector.InlineProperty()]
  public unsafe partial struct HealthApplicator {
    public const Int32 SIZE = 24;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(1)]
    [Sirenix.OdinInspector.ValidateInput("OdinValidateAppliance")]
    [Sirenix.OdinInspector.LabelWidth(100)]
    public HealthAttributeAppliance Appliance;
    [FieldOffset(2)]
    [Sirenix.OdinInspector.ValidateInput("OdinValidateOperation")]
    [Sirenix.OdinInspector.LabelWidth(100)]
    public HealthAttributeOperation Operation;
    [FieldOffset(16)]
    [Sirenix.OdinInspector.ValidateInput("OdinValidateValue")]
    [Sirenix.OdinInspector.LabelWidth(100)]
    public FP Value;
    [FieldOffset(4)]
    [Sirenix.OdinInspector.ShowIf("ShowValueIsPercent")]
    [Sirenix.OdinInspector.LabelWidth(100)]
    public QBoolean ValueIsPercent;
    [FieldOffset(0)]
    [Sirenix.OdinInspector.ShowIf("ShowDamageType")]
    [Sirenix.OdinInspector.ValidateInput("OdinValidateDamageType")]
    [Sirenix.OdinInspector.LabelWidth(100)]
    public EDamageType DamageType;
    [FieldOffset(8)]
    [Sirenix.OdinInspector.ShowIf("ShowDuration")]
    [Sirenix.OdinInspector.ValidateInput("OdinValidateDuration")]
    [Sirenix.OdinInspector.LabelWidth(100)]
    public FP Duration;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 15013;
        hash = hash * 31 + (Byte)Appliance;
        hash = hash * 31 + (Byte)Operation;
        hash = hash * 31 + Value.GetHashCode();
        hash = hash * 31 + ValueIsPercent.GetHashCode();
        hash = hash * 31 + (Byte)DamageType;
        hash = hash * 31 + Duration.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (HealthApplicator*)ptr;
        serializer.Stream.Serialize((Byte*)&p->DamageType);
        serializer.Stream.Serialize((Byte*)&p->Appliance);
        serializer.Stream.Serialize((Byte*)&p->Operation);
        QBoolean.Serialize(&p->ValueIsPercent, serializer);
        FP.Serialize(&p->Duration, serializer);
        FP.Serialize(&p->Value, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct HealthAttributeModifier {
    public const Int32 SIZE = 40;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(1)]
    public HealthAttributeAppliance Appliance;
    [FieldOffset(2)]
    public HealthAttributeOperation Operation;
    [FieldOffset(0)]
    public EDamageType DamageType;
    [FieldOffset(8)]
    public EntityRef SourceRef;
    [FieldOffset(16)]
    public FP Amount;
    [FieldOffset(24)]
    public FP Duration;
    [FieldOffset(32)]
    [HideInInspector()]
    public FP Timer;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 16361;
        hash = hash * 31 + (Byte)Appliance;
        hash = hash * 31 + (Byte)Operation;
        hash = hash * 31 + (Byte)DamageType;
        hash = hash * 31 + SourceRef.GetHashCode();
        hash = hash * 31 + Amount.GetHashCode();
        hash = hash * 31 + Duration.GetHashCode();
        hash = hash * 31 + Timer.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (HealthAttributeModifier*)ptr;
        serializer.Stream.Serialize((Byte*)&p->DamageType);
        serializer.Stream.Serialize((Byte*)&p->Appliance);
        serializer.Stream.Serialize((Byte*)&p->Operation);
        EntityRef.Serialize(&p->SourceRef, serializer);
        FP.Serialize(&p->Amount, serializer);
        FP.Serialize(&p->Duration, serializer);
        FP.Serialize(&p->Timer, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Input {
    public const Int32 SIZE = 96;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(3)]
    public Byte MovementMagnitudeEncoded;
    [FieldOffset(2)]
    public Byte MovementDirectionEncoded;
    [FieldOffset(1)]
    public Byte InterpolationOffset;
    [FieldOffset(0)]
    public Byte InterpolationAlphaEncoded;
    [FieldOffset(56)]
    public FPVector2 LookRotationDelta;
    [FieldOffset(40)]
    public FPVector2 LookRotation;
    [FieldOffset(72)]
    public FPVector3 AimTarget;
    [FieldOffset(16)]
    public Button SecondaryAction;
    [FieldOffset(4)]
    public Button AimButton;
    [FieldOffset(28)]
    public Button SprintButton;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 19249;
        hash = hash * 31 + MovementMagnitudeEncoded.GetHashCode();
        hash = hash * 31 + MovementDirectionEncoded.GetHashCode();
        hash = hash * 31 + InterpolationOffset.GetHashCode();
        hash = hash * 31 + InterpolationAlphaEncoded.GetHashCode();
        hash = hash * 31 + LookRotationDelta.GetHashCode();
        hash = hash * 31 + LookRotation.GetHashCode();
        hash = hash * 31 + AimTarget.GetHashCode();
        hash = hash * 31 + SecondaryAction.GetHashCode();
        hash = hash * 31 + AimButton.GetHashCode();
        hash = hash * 31 + SprintButton.GetHashCode();
        return hash;
      }
    }
    static partial void GetMaxCountCodeGen(ref int maxCount) {
      maxCount = 6;
    }
    public Boolean IsDown(InputButtons button) {
      switch (button) {
        case InputButtons.SecondaryAction: return SecondaryAction.IsDown;
        case InputButtons.AimButton: return AimButton.IsDown;
        case InputButtons.SprintButton: return SprintButton.IsDown;
        default: return false;
      }
    }
    public Boolean WasPressed(InputButtons button) {
      switch (button) {
        case InputButtons.SecondaryAction: return SecondaryAction.WasPressed;
        case InputButtons.AimButton: return AimButton.WasPressed;
        case InputButtons.SprintButton: return SprintButton.WasPressed;
        default: return false;
      }
    }
    static partial void SerializeCodeGen(void* ptr, FrameSerializer serializer) {
        var p = (Input*)ptr;
        serializer.Stream.Serialize(&p->InterpolationAlphaEncoded);
        serializer.Stream.Serialize(&p->InterpolationOffset);
        serializer.Stream.Serialize(&p->MovementDirectionEncoded);
        serializer.Stream.Serialize(&p->MovementMagnitudeEncoded);
        Button.Serialize(&p->AimButton, serializer);
        Button.Serialize(&p->SecondaryAction, serializer);
        Button.Serialize(&p->SprintButton, serializer);
        FPVector2.Serialize(&p->LookRotation, serializer);
        FPVector2.Serialize(&p->LookRotationDelta, serializer);
        FPVector3.Serialize(&p->AimTarget, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct KCCCollision {
    public const Int32 SIZE = 24;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public EKCCCollisionSource Source;
    [FieldOffset(16)]
    public EntityRef Reference;
    [FieldOffset(8)]
    public AssetRef Processor;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 7523;
        hash = hash * 31 + (Byte)Source;
        hash = hash * 31 + Reference.GetHashCode();
        hash = hash * 31 + Processor.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (KCCCollision*)ptr;
        serializer.Stream.Serialize((Byte*)&p->Source);
        AssetRef.Serialize(&p->Processor, serializer);
        EntityRef.Serialize(&p->Reference, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct KCCData {
    public const Int32 SIZE = 528;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(8)]
    public QBoolean IsActive;
    [FieldOffset(72)]
    public FP LookPitch;
    [FieldOffset(80)]
    public FP LookYaw;
    [FieldOffset(120)]
    public FPVector3 BasePosition;
    [FieldOffset(144)]
    public FPVector3 DesiredPosition;
    [FieldOffset(504)]
    public FPVector3 TargetPosition;
    [FieldOffset(40)]
    public FP DeltaTime;
    [FieldOffset(360)]
    public FPVector3 InputDirection;
    [FieldOffset(384)]
    public FPVector3 JumpImpulse;
    [FieldOffset(264)]
    public FPVector3 Gravity;
    [FieldOffset(88)]
    public FP MaxGroundAngle;
    [FieldOffset(104)]
    public FP MaxWallAngle;
    [FieldOffset(96)]
    public FP MaxHangAngle;
    [FieldOffset(240)]
    public FPVector3 ExternalImpulse;
    [FieldOffset(216)]
    public FPVector3 ExternalForce;
    [FieldOffset(192)]
    public FPVector3 ExternalDelta;
    [FieldOffset(64)]
    public FP KinematicSpeed;
    [FieldOffset(432)]
    public FPVector3 KinematicTangent;
    [FieldOffset(408)]
    public FPVector3 KinematicDirection;
    [FieldOffset(456)]
    public FPVector3 KinematicVelocity;
    [FieldOffset(168)]
    public FPVector3 DynamicVelocity;
    [FieldOffset(112)]
    public FP RealSpeed;
    [FieldOffset(480)]
    public FPVector3 RealVelocity;
    [FieldOffset(0)]
    public QBoolean HasJumped;
    [FieldOffset(4)]
    public QBoolean HasTeleported;
    [FieldOffset(12)]
    public QBoolean IsGrounded;
    [FieldOffset(24)]
    public QBoolean WasGrounded;
    [FieldOffset(20)]
    public QBoolean IsSteppingUp;
    [FieldOffset(32)]
    public QBoolean WasSteppingUp;
    [FieldOffset(16)]
    public QBoolean IsSnappingToGround;
    [FieldOffset(28)]
    public QBoolean WasSnappingToGround;
    [FieldOffset(288)]
    public FPVector3 GroundNormal;
    [FieldOffset(336)]
    public FPVector3 GroundTangent;
    [FieldOffset(312)]
    public FPVector3 GroundPosition;
    [FieldOffset(56)]
    public FP GroundDistance;
    [FieldOffset(48)]
    public FP GroundAngle;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 6067;
        hash = hash * 31 + IsActive.GetHashCode();
        hash = hash * 31 + LookPitch.GetHashCode();
        hash = hash * 31 + LookYaw.GetHashCode();
        hash = hash * 31 + BasePosition.GetHashCode();
        hash = hash * 31 + DesiredPosition.GetHashCode();
        hash = hash * 31 + TargetPosition.GetHashCode();
        hash = hash * 31 + DeltaTime.GetHashCode();
        hash = hash * 31 + InputDirection.GetHashCode();
        hash = hash * 31 + JumpImpulse.GetHashCode();
        hash = hash * 31 + Gravity.GetHashCode();
        hash = hash * 31 + MaxGroundAngle.GetHashCode();
        hash = hash * 31 + MaxWallAngle.GetHashCode();
        hash = hash * 31 + MaxHangAngle.GetHashCode();
        hash = hash * 31 + ExternalImpulse.GetHashCode();
        hash = hash * 31 + ExternalForce.GetHashCode();
        hash = hash * 31 + ExternalDelta.GetHashCode();
        hash = hash * 31 + KinematicSpeed.GetHashCode();
        hash = hash * 31 + KinematicTangent.GetHashCode();
        hash = hash * 31 + KinematicDirection.GetHashCode();
        hash = hash * 31 + KinematicVelocity.GetHashCode();
        hash = hash * 31 + DynamicVelocity.GetHashCode();
        hash = hash * 31 + RealSpeed.GetHashCode();
        hash = hash * 31 + RealVelocity.GetHashCode();
        hash = hash * 31 + HasJumped.GetHashCode();
        hash = hash * 31 + HasTeleported.GetHashCode();
        hash = hash * 31 + IsGrounded.GetHashCode();
        hash = hash * 31 + WasGrounded.GetHashCode();
        hash = hash * 31 + IsSteppingUp.GetHashCode();
        hash = hash * 31 + WasSteppingUp.GetHashCode();
        hash = hash * 31 + IsSnappingToGround.GetHashCode();
        hash = hash * 31 + WasSnappingToGround.GetHashCode();
        hash = hash * 31 + GroundNormal.GetHashCode();
        hash = hash * 31 + GroundTangent.GetHashCode();
        hash = hash * 31 + GroundPosition.GetHashCode();
        hash = hash * 31 + GroundDistance.GetHashCode();
        hash = hash * 31 + GroundAngle.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (KCCData*)ptr;
        QBoolean.Serialize(&p->HasJumped, serializer);
        QBoolean.Serialize(&p->HasTeleported, serializer);
        QBoolean.Serialize(&p->IsActive, serializer);
        QBoolean.Serialize(&p->IsGrounded, serializer);
        QBoolean.Serialize(&p->IsSnappingToGround, serializer);
        QBoolean.Serialize(&p->IsSteppingUp, serializer);
        QBoolean.Serialize(&p->WasGrounded, serializer);
        QBoolean.Serialize(&p->WasSnappingToGround, serializer);
        QBoolean.Serialize(&p->WasSteppingUp, serializer);
        FP.Serialize(&p->DeltaTime, serializer);
        FP.Serialize(&p->GroundAngle, serializer);
        FP.Serialize(&p->GroundDistance, serializer);
        FP.Serialize(&p->KinematicSpeed, serializer);
        FP.Serialize(&p->LookPitch, serializer);
        FP.Serialize(&p->LookYaw, serializer);
        FP.Serialize(&p->MaxGroundAngle, serializer);
        FP.Serialize(&p->MaxHangAngle, serializer);
        FP.Serialize(&p->MaxWallAngle, serializer);
        FP.Serialize(&p->RealSpeed, serializer);
        FPVector3.Serialize(&p->BasePosition, serializer);
        FPVector3.Serialize(&p->DesiredPosition, serializer);
        FPVector3.Serialize(&p->DynamicVelocity, serializer);
        FPVector3.Serialize(&p->ExternalDelta, serializer);
        FPVector3.Serialize(&p->ExternalForce, serializer);
        FPVector3.Serialize(&p->ExternalImpulse, serializer);
        FPVector3.Serialize(&p->Gravity, serializer);
        FPVector3.Serialize(&p->GroundNormal, serializer);
        FPVector3.Serialize(&p->GroundPosition, serializer);
        FPVector3.Serialize(&p->GroundTangent, serializer);
        FPVector3.Serialize(&p->InputDirection, serializer);
        FPVector3.Serialize(&p->JumpImpulse, serializer);
        FPVector3.Serialize(&p->KinematicDirection, serializer);
        FPVector3.Serialize(&p->KinematicTangent, serializer);
        FPVector3.Serialize(&p->KinematicVelocity, serializer);
        FPVector3.Serialize(&p->RealVelocity, serializer);
        FPVector3.Serialize(&p->TargetPosition, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct KCCIgnore {
    public const Int32 SIZE = 16;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public EKCCIgnoreSource Source;
    [FieldOffset(8)]
    public EntityRef Reference;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 283;
        hash = hash * 31 + (Byte)Source;
        hash = hash * 31 + Reference.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (KCCIgnore*)ptr;
        serializer.Stream.Serialize((Byte*)&p->Source);
        EntityRef.Serialize(&p->Reference, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct KCCModifier {
    public const Int32 SIZE = 16;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public AssetRef Processor;
    [FieldOffset(8)]
    public EntityRef Entity;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 15959;
        hash = hash * 31 + Processor.GetHashCode();
        hash = hash * 31 + Entity.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (KCCModifier*)ptr;
        AssetRef.Serialize(&p->Processor, serializer);
        EntityRef.Serialize(&p->Entity, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct LineData {
    public const Int32 SIZE = 48;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(24)]
    public FPVector3 Start;
    [FieldOffset(0)]
    public FPVector3 End;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 7109;
        hash = hash * 31 + Start.GetHashCode();
        hash = hash * 31 + End.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (LineData*)ptr;
        FPVector3.Serialize(&p->End, serializer);
        FPVector3.Serialize(&p->Start, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct PerceptionMemoryEntry {
    public const Int32 SIZE = 96;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(8)]
    public EntityRef Target;
    [FieldOffset(48)]
    public FPVector3 LastKnownPosition;
    [FieldOffset(72)]
    public FPVector3 LastKnownVelocity;
    [FieldOffset(40)]
    public FP LastSeenTime;
    [FieldOffset(32)]
    public FP LastHeardTime;
    [FieldOffset(16)]
    public FP Confidence;
    [FieldOffset(0)]
    public PerceptionType PerceptionType;
    [FieldOffset(24)]
    public FP ContinuousVisionTime;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 1483;
        hash = hash * 31 + Target.GetHashCode();
        hash = hash * 31 + LastKnownPosition.GetHashCode();
        hash = hash * 31 + LastKnownVelocity.GetHashCode();
        hash = hash * 31 + LastSeenTime.GetHashCode();
        hash = hash * 31 + LastHeardTime.GetHashCode();
        hash = hash * 31 + Confidence.GetHashCode();
        hash = hash * 31 + (Int32)PerceptionType;
        hash = hash * 31 + ContinuousVisionTime.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (PerceptionMemoryEntry*)ptr;
        serializer.Stream.Serialize((Int32*)&p->PerceptionType);
        EntityRef.Serialize(&p->Target, serializer);
        FP.Serialize(&p->Confidence, serializer);
        FP.Serialize(&p->ContinuousVisionTime, serializer);
        FP.Serialize(&p->LastHeardTime, serializer);
        FP.Serialize(&p->LastSeenTime, serializer);
        FPVector3.Serialize(&p->LastKnownPosition, serializer);
        FPVector3.Serialize(&p->LastKnownVelocity, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct RayData {
    public const Int32 SIZE = 48;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(24)]
    public FPVector3 Origin;
    [FieldOffset(0)]
    public FPVector3 Direction;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 17659;
        hash = hash * 31 + Origin.GetHashCode();
        hash = hash * 31 + Direction.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (RayData*)ptr;
        FPVector3.Serialize(&p->Direction, serializer);
        FPVector3.Serialize(&p->Origin, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct TeamData {
    public const Int32 SIZE = 24;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(16)]
    public UInt64 PartyKeyHash;
    [FieldOffset(8)]
    public EntityRef TeamSpawnPoint;
    [FieldOffset(0)]
    public EntityRef TeamExitZoneRef;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 9629;
        hash = hash * 31 + PartyKeyHash.GetHashCode();
        hash = hash * 31 + TeamSpawnPoint.GetHashCode();
        hash = hash * 31 + TeamExitZoneRef.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (TeamData*)ptr;
        EntityRef.Serialize(&p->TeamExitZoneRef, serializer);
        EntityRef.Serialize(&p->TeamSpawnPoint, serializer);
        serializer.Stream.Serialize(&p->PartyKeyHash);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct UnitStats {
    public const Int32 SIZE = 240;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(192)]
    public FPBoostedValue moveSpeed;
    [FieldOffset(216)]
    public FPBoostedValue rotationSpeed;
    [FieldOffset(168)]
    public FPBoostedValue maxWeight;
    [FieldOffset(144)]
    public FPBoostedValue loadoutWidth;
    [FieldOffset(120)]
    public FPBoostedValue loadoutHeight;
    [FieldOffset(96)]
    public FPBoostedValue jumpImpulse;
    [FieldOffset(16)]
    public FPBoostedMultiplier resistAllMultiplier;
    [FieldOffset(24)]
    public FPBoostedMultiplier resistBulletMultiplier;
    [FieldOffset(56)]
    public FPBoostedMultiplier resistFireMultiplier;
    [FieldOffset(48)]
    public FPBoostedMultiplier resistExplosionMultiplier;
    [FieldOffset(64)]
    public FPBoostedMultiplier resistMeleeMultiplier;
    [FieldOffset(72)]
    public FPBoostedMultiplier resistZoneMultiplier;
    [FieldOffset(32)]
    public FPBoostedMultiplier resistCritChanceMultiplier;
    [FieldOffset(40)]
    public FPBoostedMultiplier resistCritDamageMultiplier;
    [FieldOffset(88)]
    public FPBoostedMultiplier visionDistanceMultiplier;
    [FieldOffset(80)]
    public FPBoostedMultiplier shotImpulse;
    [FieldOffset(8)]
    public FPBoostedMultiplier audioVolume;
    [FieldOffset(0)]
    public FPBoostedMultiplier audioDistance;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 17377;
        hash = hash * 31 + moveSpeed.GetHashCode();
        hash = hash * 31 + rotationSpeed.GetHashCode();
        hash = hash * 31 + maxWeight.GetHashCode();
        hash = hash * 31 + loadoutWidth.GetHashCode();
        hash = hash * 31 + loadoutHeight.GetHashCode();
        hash = hash * 31 + jumpImpulse.GetHashCode();
        hash = hash * 31 + resistAllMultiplier.GetHashCode();
        hash = hash * 31 + resistBulletMultiplier.GetHashCode();
        hash = hash * 31 + resistFireMultiplier.GetHashCode();
        hash = hash * 31 + resistExplosionMultiplier.GetHashCode();
        hash = hash * 31 + resistMeleeMultiplier.GetHashCode();
        hash = hash * 31 + resistZoneMultiplier.GetHashCode();
        hash = hash * 31 + resistCritChanceMultiplier.GetHashCode();
        hash = hash * 31 + resistCritDamageMultiplier.GetHashCode();
        hash = hash * 31 + visionDistanceMultiplier.GetHashCode();
        hash = hash * 31 + shotImpulse.GetHashCode();
        hash = hash * 31 + audioVolume.GetHashCode();
        hash = hash * 31 + audioDistance.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (UnitStats*)ptr;
        Quantum.FPBoostedMultiplier.Serialize(&p->audioDistance, serializer);
        Quantum.FPBoostedMultiplier.Serialize(&p->audioVolume, serializer);
        Quantum.FPBoostedMultiplier.Serialize(&p->resistAllMultiplier, serializer);
        Quantum.FPBoostedMultiplier.Serialize(&p->resistBulletMultiplier, serializer);
        Quantum.FPBoostedMultiplier.Serialize(&p->resistCritChanceMultiplier, serializer);
        Quantum.FPBoostedMultiplier.Serialize(&p->resistCritDamageMultiplier, serializer);
        Quantum.FPBoostedMultiplier.Serialize(&p->resistExplosionMultiplier, serializer);
        Quantum.FPBoostedMultiplier.Serialize(&p->resistFireMultiplier, serializer);
        Quantum.FPBoostedMultiplier.Serialize(&p->resistMeleeMultiplier, serializer);
        Quantum.FPBoostedMultiplier.Serialize(&p->resistZoneMultiplier, serializer);
        Quantum.FPBoostedMultiplier.Serialize(&p->shotImpulse, serializer);
        Quantum.FPBoostedMultiplier.Serialize(&p->visionDistanceMultiplier, serializer);
        Quantum.FPBoostedValue.Serialize(&p->jumpImpulse, serializer);
        Quantum.FPBoostedValue.Serialize(&p->loadoutHeight, serializer);
        Quantum.FPBoostedValue.Serialize(&p->loadoutWidth, serializer);
        Quantum.FPBoostedValue.Serialize(&p->maxWeight, serializer);
        Quantum.FPBoostedValue.Serialize(&p->moveSpeed, serializer);
        Quantum.FPBoostedValue.Serialize(&p->rotationSpeed, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct VisibilityArea {
    public const Int32 SIZE = 24;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public QBoolean IsEnable;
    [FieldOffset(8)]
    public FP Angle;
    [FieldOffset(16)]
    public FP Radius;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 12203;
        hash = hash * 31 + IsEnable.GetHashCode();
        hash = hash * 31 + Angle.GetHashCode();
        hash = hash * 31 + Radius.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (VisibilityArea*)ptr;
        QBoolean.Serialize(&p->IsEnable, serializer);
        FP.Serialize(&p->Angle, serializer);
        FP.Serialize(&p->Radius, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct WeaponStats {
    public const Int32 SIZE = 328;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(160)]
    public FPBoostedValue minDamage;
    [FieldOffset(136)]
    public FPBoostedValue maxDamage;
    [FieldOffset(232)]
    public FPBoostedValue spreadAngle;
    [FieldOffset(208)]
    public FPBoostedValue reloadingTime;
    [FieldOffset(40)]
    public FPBoostedValue attackDistance;
    [FieldOffset(256)]
    public FPBoostedValue triggerAngleX;
    [FieldOffset(280)]
    public FPBoostedValue triggerAngleY;
    [FieldOffset(112)]
    public FPBoostedValue maxAmmo;
    [FieldOffset(64)]
    public FPBoostedValue critChance;
    [FieldOffset(88)]
    public FPBoostedValue critDamage;
    [FieldOffset(184)]
    public FPBoostedValue preShotAimingSeconds;
    [FieldOffset(304)]
    public FPBoostedValue weaponShotSoundRange;
    [FieldOffset(16)]
    public FPBoostedMultiplier recoilXMultiplier;
    [FieldOffset(24)]
    public FPBoostedMultiplier recoilYMultiplier;
    [FieldOffset(8)]
    public FPBoostedMultiplier projectileSpeedMultiplier;
    [FieldOffset(0)]
    public FPBoostedMultiplier distanceDamageMultiplier;
    [FieldOffset(32)]
    public FPBoostedMultiplier shootingSpreadInMovementMultiplier;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 17317;
        hash = hash * 31 + minDamage.GetHashCode();
        hash = hash * 31 + maxDamage.GetHashCode();
        hash = hash * 31 + spreadAngle.GetHashCode();
        hash = hash * 31 + reloadingTime.GetHashCode();
        hash = hash * 31 + attackDistance.GetHashCode();
        hash = hash * 31 + triggerAngleX.GetHashCode();
        hash = hash * 31 + triggerAngleY.GetHashCode();
        hash = hash * 31 + maxAmmo.GetHashCode();
        hash = hash * 31 + critChance.GetHashCode();
        hash = hash * 31 + critDamage.GetHashCode();
        hash = hash * 31 + preShotAimingSeconds.GetHashCode();
        hash = hash * 31 + weaponShotSoundRange.GetHashCode();
        hash = hash * 31 + recoilXMultiplier.GetHashCode();
        hash = hash * 31 + recoilYMultiplier.GetHashCode();
        hash = hash * 31 + projectileSpeedMultiplier.GetHashCode();
        hash = hash * 31 + distanceDamageMultiplier.GetHashCode();
        hash = hash * 31 + shootingSpreadInMovementMultiplier.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (WeaponStats*)ptr;
        Quantum.FPBoostedMultiplier.Serialize(&p->distanceDamageMultiplier, serializer);
        Quantum.FPBoostedMultiplier.Serialize(&p->projectileSpeedMultiplier, serializer);
        Quantum.FPBoostedMultiplier.Serialize(&p->recoilXMultiplier, serializer);
        Quantum.FPBoostedMultiplier.Serialize(&p->recoilYMultiplier, serializer);
        Quantum.FPBoostedMultiplier.Serialize(&p->shootingSpreadInMovementMultiplier, serializer);
        Quantum.FPBoostedValue.Serialize(&p->attackDistance, serializer);
        Quantum.FPBoostedValue.Serialize(&p->critChance, serializer);
        Quantum.FPBoostedValue.Serialize(&p->critDamage, serializer);
        Quantum.FPBoostedValue.Serialize(&p->maxAmmo, serializer);
        Quantum.FPBoostedValue.Serialize(&p->maxDamage, serializer);
        Quantum.FPBoostedValue.Serialize(&p->minDamage, serializer);
        Quantum.FPBoostedValue.Serialize(&p->preShotAimingSeconds, serializer);
        Quantum.FPBoostedValue.Serialize(&p->reloadingTime, serializer);
        Quantum.FPBoostedValue.Serialize(&p->spreadAngle, serializer);
        Quantum.FPBoostedValue.Serialize(&p->triggerAngleX, serializer);
        Quantum.FPBoostedValue.Serialize(&p->triggerAngleY, serializer);
        Quantum.FPBoostedValue.Serialize(&p->weaponShotSoundRange, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct _globals_ {
    public const Int32 SIZE = 1224;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public AssetRef<Map> Map;
    [FieldOffset(8)]
    public FP DeltaTime;
    [FieldOffset(16)]
    public NavMeshRegionMask NavMeshRegions;
    [FieldOffset(80)]
    public PhysicsEngineState PhysicsState2D;
    [FieldOffset(96)]
    public PhysicsEngineState PhysicsState3D;
    [FieldOffset(112)]
    public RNGSession RngSession;
    [FieldOffset(128)]
    public FrameMetaData FrameMetaData;
    [FieldOffset(176)]
    public BitSet1024 Systems;
    [FieldOffset(304)]
    public PhysicsSceneSettings PhysicsSettings;
    [FieldOffset(600)]
    public Int32 PlayerConnectedCount;
    [FieldOffset(608)]
    [FramePrinter.FixedArrayAttribute(typeof(Input), 6)]
    private fixed Byte _input_[576];
    [FieldOffset(1184)]
    public BitSet6 PlayerLastConnectionState;
    [FieldOffset(1192)]
    public Int16 BotSpawnCounter;
    [FieldOffset(1196)]
    public EGameStates GameState;
    [FieldOffset(1216)]
    public FP GameStateTimer;
    [FieldOffset(1200)]
    public QBoolean CharacterLoadoutModificationEventEnabled;
    [FieldOffset(1204)]
    public QDictionaryPtr<Int32, GlobalVisibilityData> VisibleUnitsByTeam;
    [FieldOffset(1208)]
    public QListPtr<TeamData> TeamsData;
    [FieldOffset(1212)]
    public QListPtr<Way> Ways;
    public readonly FixedArray<Input> input {
      get {
        fixed (byte* p = _input_) { return new FixedArray<Input>(p, 96, 6); }
      }
    }
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 12473;
        hash = hash * 31 + Map.GetHashCode();
        hash = hash * 31 + DeltaTime.GetHashCode();
        hash = hash * 31 + NavMeshRegions.GetHashCode();
        hash = hash * 31 + PhysicsState2D.GetHashCode();
        hash = hash * 31 + PhysicsState3D.GetHashCode();
        hash = hash * 31 + RngSession.GetHashCode();
        hash = hash * 31 + FrameMetaData.GetHashCode();
        hash = hash * 31 + Systems.GetHashCode();
        hash = hash * 31 + PhysicsSettings.GetHashCode();
        hash = hash * 31 + PlayerConnectedCount.GetHashCode();
        hash = hash * 31 + HashCodeUtils.GetArrayHashCode(input);
        hash = hash * 31 + PlayerLastConnectionState.GetHashCode();
        hash = hash * 31 + BotSpawnCounter.GetHashCode();
        hash = hash * 31 + (Int32)GameState;
        hash = hash * 31 + GameStateTimer.GetHashCode();
        hash = hash * 31 + CharacterLoadoutModificationEventEnabled.GetHashCode();
        hash = hash * 31 + VisibleUnitsByTeam.GetHashCode();
        hash = hash * 31 + TeamsData.GetHashCode();
        hash = hash * 31 + Ways.GetHashCode();
        return hash;
      }
    }
    partial void ClearPointersPartial(FrameBase f, EntityRef entity) {
      if (Ways != default) {
        var list = f.ResolveList(this.Ways);
        for (int i = 0; i < list.Count; ++i) {
          list.GetPointer(i)->ClearPointers(f, entity);
        }
      }
      VisibleUnitsByTeam = default;
      TeamsData = default;
      Ways = default;
    }
    partial void AllocatePointersPartial(FrameBase f, EntityRef entity) {
      if (Ways != default) {
        var list = f.ResolveList(this.Ways);
        for (int i = 0; i < list.Count; ++i) {
          list.GetPointer(i)->AllocatePointers(f, entity);
        }
      }
    }
    static partial void SerializeCodeGen(void* ptr, FrameSerializer serializer) {
        var p = (_globals_*)ptr;
        AssetRef.Serialize(&p->Map, serializer);
        FP.Serialize(&p->DeltaTime, serializer);
        NavMeshRegionMask.Serialize(&p->NavMeshRegions, serializer);
        PhysicsEngineState.Serialize(&p->PhysicsState2D, serializer);
        PhysicsEngineState.Serialize(&p->PhysicsState3D, serializer);
        RNGSession.Serialize(&p->RngSession, serializer);
        FrameMetaData.Serialize(&p->FrameMetaData, serializer);
        Quantum.BitSet1024.Serialize(&p->Systems, serializer);
        PhysicsSceneSettings.Serialize(&p->PhysicsSettings, serializer);
        serializer.Stream.Serialize(&p->PlayerConnectedCount);
        FixedArray.Serialize(p->input, serializer, Statics.SerializeInput);
        Quantum.BitSet6.Serialize(&p->PlayerLastConnectionState, serializer);
        serializer.Stream.Serialize(&p->BotSpawnCounter);
        serializer.Stream.Serialize((Int32*)&p->GameState);
        QBoolean.Serialize(&p->CharacterLoadoutModificationEventEnabled, serializer);
        QDictionary.Serialize(&p->VisibleUnitsByTeam, serializer, Statics.SerializeInt32, Statics.SerializeGlobalVisibilityData);
        QList.Serialize(&p->TeamsData, serializer, Statics.SerializeTeamData);
        QList.Serialize(&p->Ways, serializer, Statics.SerializeWay);
        FP.Serialize(&p->GameStateTimer, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  [Union()]
  public unsafe partial struct UnionDrawData {
    public const Int32 SIZE = 80;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    private Int32 _field_used_;
    [FieldOffset(8)]
    [FieldOverlap(8)]
    [FramePrinter.PrintIf("_field_used_", Quantum.UnionDrawData.LINEDATA)]
    private LineData _LineData;
    [FieldOffset(8)]
    [FieldOverlap(8)]
    [FramePrinter.PrintIf("_field_used_", Quantum.UnionDrawData.CIRCLEDATA)]
    private CircleData _CircleData;
    [FieldOffset(8)]
    [FieldOverlap(8)]
    [FramePrinter.PrintIf("_field_used_", Quantum.UnionDrawData.RAYDATA)]
    private RayData _RayData;
    public const Int32 LINEDATA = 1;
    public const Int32 CIRCLEDATA = 2;
    public const Int32 RAYDATA = 3;
    public readonly Int32 Field {
      get {
        return _field_used_;
      }
    }
    public LineData* LineData {
      get {
        fixed (LineData* p = &_LineData) {
          if (_field_used_ != LINEDATA) {
            Native.Utils.Clear(p, 48);
            _field_used_ = LINEDATA;
          }
          return p;
        }
      }
    }
    public CircleData* CircleData {
      get {
        fixed (CircleData* p = &_CircleData) {
          if (_field_used_ != CIRCLEDATA) {
            Native.Utils.Clear(p, 72);
            _field_used_ = CIRCLEDATA;
          }
          return p;
        }
      }
    }
    public RayData* RayData {
      get {
        fixed (RayData* p = &_RayData) {
          if (_field_used_ != RAYDATA) {
            Native.Utils.Clear(p, 48);
            _field_used_ = RAYDATA;
          }
          return p;
        }
      }
    }
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 11743;
        hash = hash * 31 + _field_used_.GetHashCode();
        hash = hash * 31 + _LineData.GetHashCode();
        hash = hash * 31 + _CircleData.GetHashCode();
        hash = hash * 31 + _RayData.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (UnionDrawData*)ptr;
        if (serializer.InputMode) {
          serializer.Stream.SerializeBuffer((byte*)p, Quantum.UnionDrawData.SIZE);
          return;
        }
        serializer.Stream.Serialize(&p->_field_used_);
        if (p->_field_used_ == CIRCLEDATA) {
          Quantum.CircleData.Serialize(&p->_CircleData, serializer);
        }
        if (p->_field_used_ == LINEDATA) {
          Quantum.LineData.Serialize(&p->_LineData, serializer);
        }
        if (p->_field_used_ == RAYDATA) {
          Quantum.RayData.Serialize(&p->_RayData, serializer);
        }
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Ability : Quantum.IComponent {
    public const Int32 SIZE = 104;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(80)]
    [ExcludeFromPrototype()]
    public CountdownTimer InputBufferTimer;
    [FieldOffset(32)]
    [ExcludeFromPrototype()]
    public CountdownTimer DelayTimer;
    [FieldOffset(56)]
    [ExcludeFromPrototype()]
    public CountdownTimer DurationTimer;
    [FieldOffset(8)]
    [ExcludeFromPrototype()]
    public CountdownTimer CooldownTimer;
    [FieldOffset(0)]
    public AssetRef<AbilityItemAsset> Config;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 6343;
        hash = hash * 31 + InputBufferTimer.GetHashCode();
        hash = hash * 31 + DelayTimer.GetHashCode();
        hash = hash * 31 + DurationTimer.GetHashCode();
        hash = hash * 31 + CooldownTimer.GetHashCode();
        hash = hash * 31 + Config.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (Ability*)ptr;
        AssetRef.Serialize(&p->Config, serializer);
        Quantum.CountdownTimer.Serialize(&p->CooldownTimer, serializer);
        Quantum.CountdownTimer.Serialize(&p->DelayTimer, serializer);
        Quantum.CountdownTimer.Serialize(&p->DurationTimer, serializer);
        Quantum.CountdownTimer.Serialize(&p->InputBufferTimer, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct AnimationTriggers : Quantum.IComponent {
    public const Int32 SIZE = 28;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(20)]
    [HideInInspector()]
    public QBoolean Reloading;
    [FieldOffset(16)]
    [HideInInspector()]
    public QBoolean PrevReloading;
    [FieldOffset(4)]
    [HideInInspector()]
    public QBoolean HideWeapon;
    [FieldOffset(0)]
    [HideInInspector()]
    public QBoolean GetWeapon;
    [FieldOffset(12)]
    [HideInInspector()]
    public QBoolean PrevHideWeapon;
    [FieldOffset(8)]
    [HideInInspector()]
    public QBoolean PrevGetWeapon;
    [FieldOffset(24)]
    [HideInInspector()]
    public QBoolean Throw;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 12253;
        hash = hash * 31 + Reloading.GetHashCode();
        hash = hash * 31 + PrevReloading.GetHashCode();
        hash = hash * 31 + HideWeapon.GetHashCode();
        hash = hash * 31 + GetWeapon.GetHashCode();
        hash = hash * 31 + PrevHideWeapon.GetHashCode();
        hash = hash * 31 + PrevGetWeapon.GetHashCode();
        hash = hash * 31 + Throw.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (AnimationTriggers*)ptr;
        QBoolean.Serialize(&p->GetWeapon, serializer);
        QBoolean.Serialize(&p->HideWeapon, serializer);
        QBoolean.Serialize(&p->PrevGetWeapon, serializer);
        QBoolean.Serialize(&p->PrevHideWeapon, serializer);
        QBoolean.Serialize(&p->PrevReloading, serializer);
        QBoolean.Serialize(&p->Reloading, serializer);
        QBoolean.Serialize(&p->Throw, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Attack : Quantum.IComponent {
    public const Int32 SIZE = 80;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(32)]
    public FP MaxDistance;
    [FieldOffset(8)]
    public AssetRef<AttackData> AttackData;
    [FieldOffset(56)]
    public HealthApplicator HealthApplicator;
    [FieldOffset(16)]
    [HideInInspector()]
    public EntityRef SourceUnitRef;
    [FieldOffset(24)]
    [HideInInspector()]
    public FP LifeTime;
    [FieldOffset(48)]
    [HideInInspector()]
    public FPBoostedMultiplier ProjectileSpeedMultiplier;
    [FieldOffset(40)]
    [HideInInspector()]
    public FPBoostedMultiplier DistanceDamageMultiplier;
    [FieldOffset(0)]
    public QBoolean IsHeadshot;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 467;
        hash = hash * 31 + MaxDistance.GetHashCode();
        hash = hash * 31 + AttackData.GetHashCode();
        hash = hash * 31 + HealthApplicator.GetHashCode();
        hash = hash * 31 + SourceUnitRef.GetHashCode();
        hash = hash * 31 + LifeTime.GetHashCode();
        hash = hash * 31 + ProjectileSpeedMultiplier.GetHashCode();
        hash = hash * 31 + DistanceDamageMultiplier.GetHashCode();
        hash = hash * 31 + IsHeadshot.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (Attack*)ptr;
        QBoolean.Serialize(&p->IsHeadshot, serializer);
        AssetRef.Serialize(&p->AttackData, serializer);
        EntityRef.Serialize(&p->SourceUnitRef, serializer);
        FP.Serialize(&p->LifeTime, serializer);
        FP.Serialize(&p->MaxDistance, serializer);
        Quantum.FPBoostedMultiplier.Serialize(&p->DistanceDamageMultiplier, serializer);
        Quantum.FPBoostedMultiplier.Serialize(&p->ProjectileSpeedMultiplier, serializer);
        Quantum.HealthApplicator.Serialize(&p->HealthApplicator, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Attributes : Quantum.IComponent {
    public const Int32 SIZE = 4;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    [AllocateOnComponentAdded()]
    [FreeOnComponentRemoved()]
    public QDictionaryPtr<EAttributeType, AttributeData> DataDictionary;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 12043;
        hash = hash * 31 + DataDictionary.GetHashCode();
        return hash;
      }
    }
    public void ClearPointers(FrameBase f, EntityRef entity) {
      if (DataDictionary != default) f.FreeDictionary(ref DataDictionary);
    }
    public static void OnRemoved(FrameBase frame, EntityRef entity, void* ptr) {
      var p = (Quantum.Attributes*)ptr;
      p->ClearPointers((Frame)frame, entity);
    }
    public void AllocatePointers(FrameBase f, EntityRef entity) {
      f.TryAllocateDictionary(ref DataDictionary);
    }
    public static void OnAdded(FrameBase frame, EntityRef entity, void* ptr) {
      var p = (Quantum.Attributes*)ptr;
      p->AllocatePointers((Frame)frame, entity);
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (Attributes*)ptr;
        QDictionary.Serialize(&p->DataDictionary, serializer, Statics.SerializeEAttributeType, Statics.SerializeAttributeData);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct AttributesTickable : Quantum.IComponent {
    public const Int32 SIZE = 4;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    private fixed Byte _alignment_padding_[4];
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 73;
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (AttributesTickable*)ptr;
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Bot : Quantum.IComponent {
    public const Int32 SIZE = 144;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    [ExcludeFromPrototype()]
    public Int32 UpdateFrameOffset;
    [FieldOffset(4)]
    [ExcludeFromPrototype()]
    public QBoolean ForceBTUpdate;
    [FieldOffset(80)]
    public EntityRef WayRef;
    [FieldOffset(104)]
    [ExcludeFromPrototype()]
    public FP SoundTimer;
    [FieldOffset(72)]
    public AssetRef<BTRoot> BehaviourTreeAsset;
    [FieldOffset(24)]
    public AssetRef<BotDifficultiesConfig> StatsMultipliers;
    [FieldOffset(64)]
    [ExcludeFromPrototype()]
    public AssetRef<BotVisionModule> VisionModule;
    [FieldOffset(32)]
    [ExcludeFromPrototype()]
    public AssetRef<BotHearingModule> HearingModule;
    [FieldOffset(56)]
    [ExcludeFromPrototype()]
    public AssetRef<BotStatePatrol> PatrolState;
    [FieldOffset(40)]
    [ExcludeFromPrototype()]
    public AssetRef<BotStateAlert> AlertState;
    [FieldOffset(48)]
    [ExcludeFromPrototype()]
    public AssetRef<BotStateCombat> CombatState;
    [FieldOffset(96)]
    [ExcludeFromPrototype()]
    public FP LastVisionUpdateTime;
    [FieldOffset(88)]
    [ExcludeFromPrototype()]
    public FP LastHearingUpdateTime;
    [FieldOffset(112)]
    [ExcludeFromPrototype()]
    public BotIntent Intent;
    [FieldOffset(12)]
    [ExcludeFromPrototype()]
    public QBoolean SuppressFire;
    [FieldOffset(20)]
    [ExcludeFromPrototype()]
    [AllocateOnComponentAdded()]
    [FreeOnComponentRemoved()]
    public QListPtr<EntityRef> VisibleEnemies;
    [FieldOffset(16)]
    [ExcludeFromPrototype()]
    [AllocateOnComponentAdded()]
    [FreeOnComponentRemoved()]
    public QListPtr<EntityRef> HeardEnemies;
    [FieldOffset(8)]
    public QBoolean IsPlayerBot;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 419;
        hash = hash * 31 + UpdateFrameOffset.GetHashCode();
        hash = hash * 31 + ForceBTUpdate.GetHashCode();
        hash = hash * 31 + WayRef.GetHashCode();
        hash = hash * 31 + SoundTimer.GetHashCode();
        hash = hash * 31 + BehaviourTreeAsset.GetHashCode();
        hash = hash * 31 + StatsMultipliers.GetHashCode();
        hash = hash * 31 + VisionModule.GetHashCode();
        hash = hash * 31 + HearingModule.GetHashCode();
        hash = hash * 31 + PatrolState.GetHashCode();
        hash = hash * 31 + AlertState.GetHashCode();
        hash = hash * 31 + CombatState.GetHashCode();
        hash = hash * 31 + LastVisionUpdateTime.GetHashCode();
        hash = hash * 31 + LastHearingUpdateTime.GetHashCode();
        hash = hash * 31 + Intent.GetHashCode();
        hash = hash * 31 + SuppressFire.GetHashCode();
        hash = hash * 31 + VisibleEnemies.GetHashCode();
        hash = hash * 31 + HeardEnemies.GetHashCode();
        hash = hash * 31 + IsPlayerBot.GetHashCode();
        return hash;
      }
    }
    public void ClearPointers(FrameBase f, EntityRef entity) {
      if (VisibleEnemies != default) f.FreeList(ref VisibleEnemies);
      if (HeardEnemies != default) f.FreeList(ref HeardEnemies);
    }
    public static void OnRemoved(FrameBase frame, EntityRef entity, void* ptr) {
      var p = (Quantum.Bot*)ptr;
      p->ClearPointers((Frame)frame, entity);
    }
    public void AllocatePointers(FrameBase f, EntityRef entity) {
      f.TryAllocateList(ref VisibleEnemies);
      f.TryAllocateList(ref HeardEnemies);
    }
    public static void OnAdded(FrameBase frame, EntityRef entity, void* ptr) {
      var p = (Quantum.Bot*)ptr;
      p->AllocatePointers((Frame)frame, entity);
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (Bot*)ptr;
        serializer.Stream.Serialize(&p->UpdateFrameOffset);
        QBoolean.Serialize(&p->ForceBTUpdate, serializer);
        QBoolean.Serialize(&p->IsPlayerBot, serializer);
        QBoolean.Serialize(&p->SuppressFire, serializer);
        QList.Serialize(&p->HeardEnemies, serializer, Statics.SerializeEntityRef);
        QList.Serialize(&p->VisibleEnemies, serializer, Statics.SerializeEntityRef);
        AssetRef.Serialize(&p->StatsMultipliers, serializer);
        AssetRef.Serialize(&p->HearingModule, serializer);
        AssetRef.Serialize(&p->AlertState, serializer);
        AssetRef.Serialize(&p->CombatState, serializer);
        AssetRef.Serialize(&p->PatrolState, serializer);
        AssetRef.Serialize(&p->VisionModule, serializer);
        AssetRef.Serialize(&p->BehaviourTreeAsset, serializer);
        EntityRef.Serialize(&p->WayRef, serializer);
        FP.Serialize(&p->LastHearingUpdateTime, serializer);
        FP.Serialize(&p->LastVisionUpdateTime, serializer);
        FP.Serialize(&p->SoundTimer, serializer);
        Quantum.BotIntent.Serialize(&p->Intent, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  [ExcludeFromPrototype()]
  public unsafe partial struct BotInvisibleByPlayer : Quantum.IComponent {
    public const Int32 SIZE = 4;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    private fixed Byte _alignment_padding_[4];
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 5801;
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BotInvisibleByPlayer*)ptr;
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BotSpawnPoint : Quantum.IComponent {
    public const Int32 SIZE = 96;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public Team Team;
    [FieldOffset(88)]
    [Header("   Way")]
    public EntityRef WayRef;
    [FieldOffset(72)]
    [RequiredRef()]
    [Header(" ")]
    public AssetRef<EntityPrototype> Prototype;
    [FieldOffset(80)]
    public AssetRef<LoadoutConfig> LoadoutOverride;
    [FieldOffset(64)]
    [Header("Behavior Tree asset")]
    public AssetRef<BTRoot> TreeOverride;
    [FieldOffset(8)]
    [Header(" ")]
    public AssetRef<BotDifficultiesConfig> StatsMultipliersOverride;
    [FieldOffset(56)]
    [Header("Perception modules")]
    public AssetRef<BotVisionModule> VisionModuleOverride;
    [FieldOffset(16)]
    public AssetRef<BotHearingModule> HearingModuleOverride;
    [FieldOffset(24)]
    public AssetRef<BotMemoryModule> MemoryModuleOverride;
    [FieldOffset(48)]
    [Header("State configs")]
    public AssetRef<BotStatePatrol> PatrolStateOverride;
    [FieldOffset(32)]
    public AssetRef<BotStateAlert> AlertStateOverride;
    [FieldOffset(40)]
    public AssetRef<BotStateCombat> CombatStateOverride;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 20393;
        hash = hash * 31 + Team.GetHashCode();
        hash = hash * 31 + WayRef.GetHashCode();
        hash = hash * 31 + Prototype.GetHashCode();
        hash = hash * 31 + LoadoutOverride.GetHashCode();
        hash = hash * 31 + TreeOverride.GetHashCode();
        hash = hash * 31 + StatsMultipliersOverride.GetHashCode();
        hash = hash * 31 + VisionModuleOverride.GetHashCode();
        hash = hash * 31 + HearingModuleOverride.GetHashCode();
        hash = hash * 31 + MemoryModuleOverride.GetHashCode();
        hash = hash * 31 + PatrolStateOverride.GetHashCode();
        hash = hash * 31 + AlertStateOverride.GetHashCode();
        hash = hash * 31 + CombatStateOverride.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BotSpawnPoint*)ptr;
        Quantum.Team.Serialize(&p->Team, serializer);
        AssetRef.Serialize(&p->StatsMultipliersOverride, serializer);
        AssetRef.Serialize(&p->HearingModuleOverride, serializer);
        AssetRef.Serialize(&p->MemoryModuleOverride, serializer);
        AssetRef.Serialize(&p->AlertStateOverride, serializer);
        AssetRef.Serialize(&p->CombatStateOverride, serializer);
        AssetRef.Serialize(&p->PatrolStateOverride, serializer);
        AssetRef.Serialize(&p->VisionModuleOverride, serializer);
        AssetRef.Serialize(&p->TreeOverride, serializer);
        AssetRef.Serialize(&p->Prototype, serializer);
        AssetRef.Serialize(&p->LoadoutOverride, serializer);
        EntityRef.Serialize(&p->WayRef, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  [ExcludeFromPrototype()]
  public unsafe partial struct CharacterFsm : Quantum.IComponent {
    public const Int32 SIZE = 16;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(8)]
    public EntityRef SelfEntity;
    [FieldOffset(0)]
    public CharacterStates CurrentState;
    [FieldOffset(4)]
    public Int32 CurrentStateTypeId;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 1871;
        hash = hash * 31 + SelfEntity.GetHashCode();
        hash = hash * 31 + (Int32)CurrentState;
        hash = hash * 31 + CurrentStateTypeId.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (CharacterFsm*)ptr;
        serializer.Stream.Serialize((Int32*)&p->CurrentState);
        serializer.Stream.Serialize(&p->CurrentStateTypeId);
        EntityRef.Serialize(&p->SelfEntity, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct CharacterLoadout : Quantum.IComponent {
    public const Int32 SIZE = 144;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(16)]
    public EntityRef SelfUnitEntity;
    [FieldOffset(24)]
    [FramePrinter.FixedArrayAttribute(typeof(EntityRef), 14)]
    private fixed Byte _SlotItemsRaw_[112];
    [FieldOffset(12)]
    [AllocateOnComponentAdded()]
    [FreeOnComponentRemoved()]
    public QListPtr<EntityRef> TrashItems;
    [FieldOffset(8)]
    [AllocateOnComponentAdded()]
    [FreeOnComponentRemoved()]
    public QListPtr<EntityRef> SafeItems;
    [FieldOffset(136)]
    public EntityRef StorageEntity;
    [FieldOffset(0)]
    [ExcludeFromPrototype()]
    public Int32 CreationFrame;
    [FieldOffset(4)]
    [ExcludeFromPrototype()]
    public Int32 UpdatedFrame;
    public readonly FixedArray<EntityRef> SlotItemsRaw {
      get {
        fixed (byte* p = _SlotItemsRaw_) { return new FixedArray<EntityRef>(p, 8, 14); }
      }
    }
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 9811;
        hash = hash * 31 + SelfUnitEntity.GetHashCode();
        hash = hash * 31 + HashCodeUtils.GetArrayHashCode(SlotItemsRaw);
        hash = hash * 31 + TrashItems.GetHashCode();
        hash = hash * 31 + SafeItems.GetHashCode();
        hash = hash * 31 + StorageEntity.GetHashCode();
        hash = hash * 31 + CreationFrame.GetHashCode();
        hash = hash * 31 + UpdatedFrame.GetHashCode();
        return hash;
      }
    }
    public void ClearPointers(FrameBase f, EntityRef entity) {
      if (TrashItems != default) f.FreeList(ref TrashItems);
      if (SafeItems != default) f.FreeList(ref SafeItems);
    }
    public static void OnRemoved(FrameBase frame, EntityRef entity, void* ptr) {
      var p = (Quantum.CharacterLoadout*)ptr;
      p->ClearPointers((Frame)frame, entity);
    }
    public void AllocatePointers(FrameBase f, EntityRef entity) {
      f.TryAllocateList(ref TrashItems);
      f.TryAllocateList(ref SafeItems);
    }
    public static void OnAdded(FrameBase frame, EntityRef entity, void* ptr) {
      var p = (Quantum.CharacterLoadout*)ptr;
      p->AllocatePointers((Frame)frame, entity);
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (CharacterLoadout*)ptr;
        serializer.Stream.Serialize(&p->CreationFrame);
        serializer.Stream.Serialize(&p->UpdatedFrame);
        QList.Serialize(&p->SafeItems, serializer, Statics.SerializeEntityRef);
        QList.Serialize(&p->TrashItems, serializer, Statics.SerializeEntityRef);
        EntityRef.Serialize(&p->SelfUnitEntity, serializer);
        FixedArray.Serialize(p->SlotItemsRaw, serializer, Statics.SerializeEntityRef);
        EntityRef.Serialize(&p->StorageEntity, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  [ExcludeFromPrototype()]
  public unsafe partial struct CharacterLoadoutModifiedMarker : Quantum.IComponent {
    public const Int32 SIZE = 8;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    [ExcludeFromPrototype()]
    public Int32 ModificationFrame;
    [FieldOffset(4)]
    [ExcludeFromPrototype()]
    [AllocateOnComponentAdded()]
    [FreeOnComponentRemoved()]
    public QHashSetPtr<QGuid> ModifiedItems;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 17117;
        hash = hash * 31 + ModificationFrame.GetHashCode();
        hash = hash * 31 + ModifiedItems.GetHashCode();
        return hash;
      }
    }
    public void ClearPointers(FrameBase f, EntityRef entity) {
      if (ModifiedItems != default) f.FreeHashSet(ref ModifiedItems);
    }
    public static void OnRemoved(FrameBase frame, EntityRef entity, void* ptr) {
      var p = (Quantum.CharacterLoadoutModifiedMarker*)ptr;
      p->ClearPointers((Frame)frame, entity);
    }
    public void AllocatePointers(FrameBase f, EntityRef entity) {
      f.TryAllocateHashSet(ref ModifiedItems);
    }
    public static void OnAdded(FrameBase frame, EntityRef entity, void* ptr) {
      var p = (Quantum.CharacterLoadoutModifiedMarker*)ptr;
      p->AllocatePointers((Frame)frame, entity);
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (CharacterLoadoutModifiedMarker*)ptr;
        serializer.Stream.Serialize(&p->ModificationFrame);
        QHashSet.Serialize(&p->ModifiedItems, serializer, Statics.SerializeQGuid);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct CharacterSafe : Quantum.IComponent {
    public const Int32 SIZE = 16;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(8)]
    public EntityRef SelfUnitEntity;
    [FieldOffset(4)]
    public Int32 Width;
    [FieldOffset(0)]
    public Int32 Height;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 20807;
        hash = hash * 31 + SelfUnitEntity.GetHashCode();
        hash = hash * 31 + Width.GetHashCode();
        hash = hash * 31 + Height.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (CharacterSafe*)ptr;
        serializer.Stream.Serialize(&p->Height);
        serializer.Stream.Serialize(&p->Width);
        EntityRef.Serialize(&p->SelfUnitEntity, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct CharacterSpectatorCamera : Quantum.IComponent {
    public const Int32 SIZE = 128;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    [ExcludeFromPrototype()]
    public EntityRef CameraEntity;
    [FieldOffset(104)]
    [ExcludeFromPrototype()]
    public FPYawPitchRoll SpectatorCameraDesiredRotation;
    [FieldOffset(80)]
    [ExcludeFromPrototype()]
    public FPYawPitchRoll SpectatorCameraCurrentRotation;
    [FieldOffset(56)]
    [ExcludeFromPrototype()]
    public FPVector3 SpectatorCameraCurrentVelocity;
    [FieldOffset(16)]
    [ExcludeFromPrototype()]
    public FP CharacterCurrentRotation;
    [FieldOffset(8)]
    [ExcludeFromPrototype()]
    public FP CharacterCurrentPitchRotation;
    [FieldOffset(24)]
    [ExcludeFromPrototype()]
    public FP CharacterCurrentVelocity;
    [FieldOffset(32)]
    [ExcludeFromPrototype()]
    public FPVector3 AimTarget;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 1009;
        hash = hash * 31 + CameraEntity.GetHashCode();
        hash = hash * 31 + SpectatorCameraDesiredRotation.GetHashCode();
        hash = hash * 31 + SpectatorCameraCurrentRotation.GetHashCode();
        hash = hash * 31 + SpectatorCameraCurrentVelocity.GetHashCode();
        hash = hash * 31 + CharacterCurrentRotation.GetHashCode();
        hash = hash * 31 + CharacterCurrentPitchRotation.GetHashCode();
        hash = hash * 31 + CharacterCurrentVelocity.GetHashCode();
        hash = hash * 31 + AimTarget.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (CharacterSpectatorCamera*)ptr;
        EntityRef.Serialize(&p->CameraEntity, serializer);
        FP.Serialize(&p->CharacterCurrentPitchRotation, serializer);
        FP.Serialize(&p->CharacterCurrentRotation, serializer);
        FP.Serialize(&p->CharacterCurrentVelocity, serializer);
        FPVector3.Serialize(&p->AimTarget, serializer);
        FPVector3.Serialize(&p->SpectatorCameraCurrentVelocity, serializer);
        Quantum.FPYawPitchRoll.Serialize(&p->SpectatorCameraCurrentRotation, serializer);
        Quantum.FPYawPitchRoll.Serialize(&p->SpectatorCameraDesiredRotation, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  [ExcludeFromPrototype()]
  public unsafe partial struct CharacterStateCrouchIdle : Quantum.IComponent {
    public const Int32 SIZE = 4;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    private fixed Byte _alignment_padding_[4];
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 17581;
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (CharacterStateCrouchIdle*)ptr;
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  [ExcludeFromPrototype()]
  public unsafe partial struct CharacterStateCrouchMove : Quantum.IComponent {
    public const Int32 SIZE = 8;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public FP CrouchSpeedMultiplier;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 683;
        hash = hash * 31 + CrouchSpeedMultiplier.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (CharacterStateCrouchMove*)ptr;
        FP.Serialize(&p->CrouchSpeedMultiplier, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  [ExcludeFromPrototype()]
  public unsafe partial struct CharacterStateDead : Quantum.IComponent {
    public const Int32 SIZE = 8;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public EntityRef KilledBy;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 11057;
        hash = hash * 31 + KilledBy.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (CharacterStateDead*)ptr;
        EntityRef.Serialize(&p->KilledBy, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  [ExcludeFromPrototype()]
  public unsafe partial struct CharacterStateHealing : Quantum.IComponent {
    public const Int32 SIZE = 48;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(8)]
    public FP Duration;
    [FieldOffset(16)]
    public FP Timer;
    [FieldOffset(0)]
    public EntityRef ItemEntity;
    [FieldOffset(24)]
    public HealthApplicator Applicator;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 1163;
        hash = hash * 31 + Duration.GetHashCode();
        hash = hash * 31 + Timer.GetHashCode();
        hash = hash * 31 + ItemEntity.GetHashCode();
        hash = hash * 31 + Applicator.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (CharacterStateHealing*)ptr;
        EntityRef.Serialize(&p->ItemEntity, serializer);
        FP.Serialize(&p->Duration, serializer);
        FP.Serialize(&p->Timer, serializer);
        Quantum.HealthApplicator.Serialize(&p->Applicator, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  [ExcludeFromPrototype()]
  public unsafe partial struct CharacterStateIdle : Quantum.IComponent {
    public const Int32 SIZE = 4;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    private fixed Byte _alignment_padding_[4];
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 7369;
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (CharacterStateIdle*)ptr;
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  [ExcludeFromPrototype()]
  public unsafe partial struct CharacterStateJump : Quantum.IComponent {
    public const Int32 SIZE = 8;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public FP AirTime;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 12799;
        hash = hash * 31 + AirTime.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (CharacterStateJump*)ptr;
        FP.Serialize(&p->AirTime, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  [ExcludeFromPrototype()]
  public unsafe partial struct CharacterStateKnifeAttack : Quantum.IComponent {
    public const Int32 SIZE = 8;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public FrameTimer StateTimer;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 14939;
        hash = hash * 31 + StateTimer.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (CharacterStateKnifeAttack*)ptr;
        FrameTimer.Serialize(&p->StateTimer, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  [ExcludeFromPrototype()]
  public unsafe partial struct CharacterStateKnocked : Quantum.IComponent {
    public const Int32 SIZE = 104;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(48)]
    public FP KnockDuration;
    [FieldOffset(72)]
    public FP KnockTimer;
    [FieldOffset(80)]
    public FP ReviveDuration;
    [FieldOffset(88)]
    public FP ReviveTimer;
    [FieldOffset(32)]
    public FP CrawlSpeedMultiplier;
    [FieldOffset(96)]
    public FP RevivedHealthValue;
    [FieldOffset(16)]
    public EntityRef Rescuer;
    [FieldOffset(0)]
    public EntityRef CandidateRescuer;
    [FieldOffset(24)]
    public FP CandidateDistanceSqr;
    [FieldOffset(8)]
    public EntityRef LastDamageSource;
    [FieldOffset(56)]
    public FP KnockHealth;
    [FieldOffset(40)]
    public FP DamageImmunityTimer;
    [FieldOffset(64)]
    public FP KnockStartHealth;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 18503;
        hash = hash * 31 + KnockDuration.GetHashCode();
        hash = hash * 31 + KnockTimer.GetHashCode();
        hash = hash * 31 + ReviveDuration.GetHashCode();
        hash = hash * 31 + ReviveTimer.GetHashCode();
        hash = hash * 31 + CrawlSpeedMultiplier.GetHashCode();
        hash = hash * 31 + RevivedHealthValue.GetHashCode();
        hash = hash * 31 + Rescuer.GetHashCode();
        hash = hash * 31 + CandidateRescuer.GetHashCode();
        hash = hash * 31 + CandidateDistanceSqr.GetHashCode();
        hash = hash * 31 + LastDamageSource.GetHashCode();
        hash = hash * 31 + KnockHealth.GetHashCode();
        hash = hash * 31 + DamageImmunityTimer.GetHashCode();
        hash = hash * 31 + KnockStartHealth.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (CharacterStateKnocked*)ptr;
        EntityRef.Serialize(&p->CandidateRescuer, serializer);
        EntityRef.Serialize(&p->LastDamageSource, serializer);
        EntityRef.Serialize(&p->Rescuer, serializer);
        FP.Serialize(&p->CandidateDistanceSqr, serializer);
        FP.Serialize(&p->CrawlSpeedMultiplier, serializer);
        FP.Serialize(&p->DamageImmunityTimer, serializer);
        FP.Serialize(&p->KnockDuration, serializer);
        FP.Serialize(&p->KnockHealth, serializer);
        FP.Serialize(&p->KnockStartHealth, serializer);
        FP.Serialize(&p->KnockTimer, serializer);
        FP.Serialize(&p->ReviveDuration, serializer);
        FP.Serialize(&p->ReviveTimer, serializer);
        FP.Serialize(&p->RevivedHealthValue, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  [ExcludeFromPrototype()]
  public unsafe partial struct CharacterStateReviving : Quantum.IComponent {
    public const Int32 SIZE = 8;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public EntityRef Target;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 7393;
        hash = hash * 31 + Target.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (CharacterStateReviving*)ptr;
        EntityRef.Serialize(&p->Target, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  [ExcludeFromPrototype()]
  public unsafe partial struct CharacterStateRoll : Quantum.IComponent {
    public const Int32 SIZE = 8;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public FrameTimer StateTimer;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 11149;
        hash = hash * 31 + StateTimer.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (CharacterStateRoll*)ptr;
        FrameTimer.Serialize(&p->StateTimer, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  [ExcludeFromPrototype()]
  public unsafe partial struct CharacterStateSprint : Quantum.IComponent {
    public const Int32 SIZE = 8;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public FP SprintSpeedMultiplier;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 16033;
        hash = hash * 31 + SprintSpeedMultiplier.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (CharacterStateSprint*)ptr;
        FP.Serialize(&p->SprintSpeedMultiplier, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  [ExcludeFromPrototype()]
  public unsafe partial struct CharacterStateWalk : Quantum.IComponent {
    public const Int32 SIZE = 4;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    private fixed Byte _alignment_padding_[4];
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 593;
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (CharacterStateWalk*)ptr;
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct DebugGizmo : Quantum.IComponent {
    public const Int32 SIZE = 88;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(8)]
    public UnionDrawData Data;
    [FieldOffset(0)]
    public ColorRGBA Color;
    [FieldOffset(4)]
    public QBoolean FromLocalTransform;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 3659;
        hash = hash * 31 + Data.GetHashCode();
        hash = hash * 31 + Color.GetHashCode();
        hash = hash * 31 + FromLocalTransform.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (DebugGizmo*)ptr;
        ColorRGBA.Serialize(&p->Color, serializer);
        QBoolean.Serialize(&p->FromLocalTransform, serializer);
        Quantum.UnionDrawData.Serialize(&p->Data, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  [ExcludeFromPrototype()]
  public unsafe partial struct DropFromUnitMarker : Quantum.IComponent {
    public const Int32 SIZE = 8;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public EntityRef SourceUnitRef;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 21001;
        hash = hash * 31 + SourceUnitRef.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (DropFromUnitMarker*)ptr;
        EntityRef.Serialize(&p->SourceUnitRef, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct ExitZone : Quantum.IComponent {
    public const Int32 SIZE = 4;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    private fixed Byte _alignment_padding_[4];
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 1181;
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (ExitZone*)ptr;
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct FlashbangBlindEffect : Quantum.IComponent {
    public const Int32 SIZE = 24;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public FP Duration;
    [FieldOffset(16)]
    public FP Strength;
    [FieldOffset(8)]
    public FP StartTime;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 5857;
        hash = hash * 31 + Duration.GetHashCode();
        hash = hash * 31 + Strength.GetHashCode();
        hash = hash * 31 + StartTime.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (FlashbangBlindEffect*)ptr;
        FP.Serialize(&p->Duration, serializer);
        FP.Serialize(&p->StartTime, serializer);
        FP.Serialize(&p->Strength, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Health : Quantum.IComponent {
    public const Int32 SIZE = 40;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(24)]
    public FP InitialValue;
    [FieldOffset(32)]
    public FP MaxValue;
    [FieldOffset(16)]
    [ExcludeFromPrototype()]
    public FP CurrentValue;
    [FieldOffset(8)]
    [ExcludeFromPrototype()]
    public EntityRef SelfEntity;
    [FieldOffset(0)]
    [AllocateOnComponentAdded()]
    [FreeOnComponentRemoved()]
    public QListPtr<HealthAttributeModifier> Modifiers;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 2111;
        hash = hash * 31 + InitialValue.GetHashCode();
        hash = hash * 31 + MaxValue.GetHashCode();
        hash = hash * 31 + CurrentValue.GetHashCode();
        hash = hash * 31 + SelfEntity.GetHashCode();
        hash = hash * 31 + Modifiers.GetHashCode();
        return hash;
      }
    }
    public void ClearPointers(FrameBase f, EntityRef entity) {
      if (Modifiers != default) f.FreeList(ref Modifiers);
    }
    public static void OnRemoved(FrameBase frame, EntityRef entity, void* ptr) {
      var p = (Quantum.Health*)ptr;
      p->ClearPointers((Frame)frame, entity);
    }
    public void AllocatePointers(FrameBase f, EntityRef entity) {
      f.TryAllocateList(ref Modifiers);
    }
    public static void OnAdded(FrameBase frame, EntityRef entity, void* ptr) {
      var p = (Quantum.Health*)ptr;
      p->AllocatePointers((Frame)frame, entity);
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (Health*)ptr;
        QList.Serialize(&p->Modifiers, serializer, Statics.SerializeHealthAttributeModifier);
        EntityRef.Serialize(&p->SelfEntity, serializer);
        FP.Serialize(&p->CurrentValue, serializer);
        FP.Serialize(&p->InitialValue, serializer);
        FP.Serialize(&p->MaxValue, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct InitializeData : Quantum.IComponentSingleton {
    public const Int32 SIZE = 16;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(8)]
    public FP FeelRoomWithBotDelay;
    [FieldOffset(0)]
    [AllocateOnComponentAdded()]
    [FreeOnComponentRemoved()]
    public QListPtr<EntityRef> NotUsedPlayerSpawnPoints;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 21379;
        hash = hash * 31 + FeelRoomWithBotDelay.GetHashCode();
        hash = hash * 31 + NotUsedPlayerSpawnPoints.GetHashCode();
        return hash;
      }
    }
    public void ClearPointers(FrameBase f, EntityRef entity) {
      if (NotUsedPlayerSpawnPoints != default) f.FreeList(ref NotUsedPlayerSpawnPoints);
    }
    public static void OnRemoved(FrameBase frame, EntityRef entity, void* ptr) {
      var p = (Quantum.InitializeData*)ptr;
      p->ClearPointers((Frame)frame, entity);
    }
    public void AllocatePointers(FrameBase f, EntityRef entity) {
      f.TryAllocateList(ref NotUsedPlayerSpawnPoints);
    }
    public static void OnAdded(FrameBase frame, EntityRef entity, void* ptr) {
      var p = (Quantum.InitializeData*)ptr;
      p->AllocatePointers((Frame)frame, entity);
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (InitializeData*)ptr;
        QList.Serialize(&p->NotUsedPlayerSpawnPoints, serializer, Statics.SerializeEntityRef);
        FP.Serialize(&p->FeelRoomWithBotDelay, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct InputContainer : Quantum.IComponent {
    public const Int32 SIZE = 136;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(40)]
    [ExcludeFromPrototype()]
    public Input Input;
    [FieldOffset(16)]
    [ExcludeFromPrototype()]
    public FPVector3 InputAccelerated;
    [FieldOffset(0)]
    [ExcludeFromPrototype()]
    public FPVector2 DesiredDirection;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 17387;
        hash = hash * 31 + Input.GetHashCode();
        hash = hash * 31 + InputAccelerated.GetHashCode();
        hash = hash * 31 + DesiredDirection.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (InputContainer*)ptr;
        FPVector2.Serialize(&p->DesiredDirection, serializer);
        FPVector3.Serialize(&p->InputAccelerated, serializer);
        Quantum.Input.Serialize(&p->Input, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct InsidePersistentAoE : Quantum.IComponent {
    public const Int32 SIZE = 16;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(8)]
    public EntityRef AttackRef;
    [FieldOffset(0)]
    public Int32 LastUpdateTick;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 11059;
        hash = hash * 31 + AttackRef.GetHashCode();
        hash = hash * 31 + LastUpdateTick.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (InsidePersistentAoE*)ptr;
        serializer.Stream.Serialize(&p->LastUpdateTick);
        EntityRef.Serialize(&p->AttackRef, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct InteractiveZone : Quantum.IComponent {
    public const Int32 SIZE = 24;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(8)]
    public AssetRef<InteractiveZoneAsset> Asset;
    [FieldOffset(16)]
    [ExcludeFromPrototype()]
    public EntityRef TriggerAreaEntity;
    [FieldOffset(0)]
    [ExcludeFromPrototype()]
    [AllocateOnComponentAdded()]
    [FreeOnComponentRemoved()]
    public QHashSetPtr<EntityRef> IgnoredEntities;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 2017;
        hash = hash * 31 + Asset.GetHashCode();
        hash = hash * 31 + TriggerAreaEntity.GetHashCode();
        hash = hash * 31 + IgnoredEntities.GetHashCode();
        return hash;
      }
    }
    public void ClearPointers(FrameBase f, EntityRef entity) {
      if (IgnoredEntities != default) f.FreeHashSet(ref IgnoredEntities);
    }
    public static void OnRemoved(FrameBase frame, EntityRef entity, void* ptr) {
      var p = (Quantum.InteractiveZone*)ptr;
      p->ClearPointers((Frame)frame, entity);
    }
    public void AllocatePointers(FrameBase f, EntityRef entity) {
      f.TryAllocateHashSet(ref IgnoredEntities);
    }
    public static void OnAdded(FrameBase frame, EntityRef entity, void* ptr) {
      var p = (Quantum.InteractiveZone*)ptr;
      p->AllocatePointers((Frame)frame, entity);
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (InteractiveZone*)ptr;
        QHashSet.Serialize(&p->IgnoredEntities, serializer, Statics.SerializeEntityRef);
        AssetRef.Serialize(&p->Asset, serializer);
        EntityRef.Serialize(&p->TriggerAreaEntity, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct InvisibilityZone : Quantum.IComponent {
    public const Int32 SIZE = 8;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public FP delayBeforeActivation;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 643;
        hash = hash * 31 + delayBeforeActivation.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (InvisibilityZone*)ptr;
        FP.Serialize(&p->delayBeforeActivation, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  [ExcludeFromPrototype()]
  public unsafe partial struct Item : Quantum.IComponent {
    public const Int32 SIZE = 112;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(24)]
    public EntityRef Owner;
    [FieldOffset(16)]
    public AssetRef<ItemAsset> Asset;
    [FieldOffset(32)]
    public QGuid MetaGuid;
    [FieldOffset(72)]
    public QGuid SafeGuid;
    [FieldOffset(0)]
    public Byte IndexI;
    [FieldOffset(1)]
    public Byte IndexJ;
    [FieldOffset(8)]
    public QBoolean Rotated;
    [FieldOffset(4)]
    public QBoolean AddToLoadoutAfterFail;
    [FieldOffset(2)]
    public UInt16 Used;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 13729;
        hash = hash * 31 + Owner.GetHashCode();
        hash = hash * 31 + Asset.GetHashCode();
        hash = hash * 31 + MetaGuid.GetHashCode();
        hash = hash * 31 + SafeGuid.GetHashCode();
        hash = hash * 31 + IndexI.GetHashCode();
        hash = hash * 31 + IndexJ.GetHashCode();
        hash = hash * 31 + Rotated.GetHashCode();
        hash = hash * 31 + AddToLoadoutAfterFail.GetHashCode();
        hash = hash * 31 + Used.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (Item*)ptr;
        serializer.Stream.Serialize(&p->IndexI);
        serializer.Stream.Serialize(&p->IndexJ);
        serializer.Stream.Serialize(&p->Used);
        QBoolean.Serialize(&p->AddToLoadoutAfterFail, serializer);
        QBoolean.Serialize(&p->Rotated, serializer);
        AssetRef.Serialize(&p->Asset, serializer);
        EntityRef.Serialize(&p->Owner, serializer);
        QGuid.Serialize(&p->MetaGuid, serializer);
        QGuid.Serialize(&p->SafeGuid, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct ItemBox : Quantum.IComponent {
    public const Int32 SIZE = 56;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(32)]
    [ExcludeFromPrototype()]
    public EntityRef SelfItemBoxEntity;
    [FieldOffset(24)]
    [ExcludeFromPrototype()]
    public EntityRef OpenerUnitRef;
    [FieldOffset(20)]
    [ExcludeFromPrototype()]
    [AllocateOnComponentAdded()]
    [FreeOnComponentRemoved()]
    public QListPtr<EntityRef> ItemRefs;
    [FieldOffset(8)]
    [ExcludeFromPrototype()]
    public QBoolean AutoUnpackNestedItems;
    [FieldOffset(16)]
    [ExcludeFromPrototype()]
    public QBoolean IsThrowAwayFeatureLocked;
    [FieldOffset(4)]
    public Int32 Width;
    [FieldOffset(0)]
    public Int32 Height;
    [FieldOffset(12)]
    public QBoolean IsBackpack;
    [FieldOffset(40)]
    public FP TimeToOpen;
    [FieldOffset(48)]
    [ExcludeFromPrototype()]
    public FP TimerToOpen;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 8803;
        hash = hash * 31 + SelfItemBoxEntity.GetHashCode();
        hash = hash * 31 + OpenerUnitRef.GetHashCode();
        hash = hash * 31 + ItemRefs.GetHashCode();
        hash = hash * 31 + AutoUnpackNestedItems.GetHashCode();
        hash = hash * 31 + IsThrowAwayFeatureLocked.GetHashCode();
        hash = hash * 31 + Width.GetHashCode();
        hash = hash * 31 + Height.GetHashCode();
        hash = hash * 31 + IsBackpack.GetHashCode();
        hash = hash * 31 + TimeToOpen.GetHashCode();
        hash = hash * 31 + TimerToOpen.GetHashCode();
        return hash;
      }
    }
    public void ClearPointers(FrameBase f, EntityRef entity) {
      if (ItemRefs != default) f.FreeList(ref ItemRefs);
    }
    public static void OnRemoved(FrameBase frame, EntityRef entity, void* ptr) {
      var p = (Quantum.ItemBox*)ptr;
      p->ClearPointers((Frame)frame, entity);
    }
    public void AllocatePointers(FrameBase f, EntityRef entity) {
      f.TryAllocateList(ref ItemRefs);
    }
    public static void OnAdded(FrameBase frame, EntityRef entity, void* ptr) {
      var p = (Quantum.ItemBox*)ptr;
      p->AllocatePointers((Frame)frame, entity);
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (ItemBox*)ptr;
        serializer.Stream.Serialize(&p->Height);
        serializer.Stream.Serialize(&p->Width);
        QBoolean.Serialize(&p->AutoUnpackNestedItems, serializer);
        QBoolean.Serialize(&p->IsBackpack, serializer);
        QBoolean.Serialize(&p->IsThrowAwayFeatureLocked, serializer);
        QList.Serialize(&p->ItemRefs, serializer, Statics.SerializeEntityRef);
        EntityRef.Serialize(&p->OpenerUnitRef, serializer);
        EntityRef.Serialize(&p->SelfItemBoxEntity, serializer);
        FP.Serialize(&p->TimeToOpen, serializer);
        FP.Serialize(&p->TimerToOpen, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  [ExcludeFromPrototype()]
  public unsafe partial struct ItemBoxKeepAliveWithoutItems : Quantum.IComponent {
    public const Int32 SIZE = 4;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    private fixed Byte _alignment_padding_[4];
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 11351;
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (ItemBoxKeepAliveWithoutItems*)ptr;
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct ItemBoxSpawnPoint : Quantum.IComponent {
    public const Int32 SIZE = 24;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(8)]
    [RequiredRef()]
    [Tooltip("   .   ,       ")]
    public AssetRef<EntityPrototype> ItemBoxPrototype;
    [FieldOffset(0)]
    [RequiredRef()]
    [FreeOnComponentRemoved()]
    public QListPtr<AssetRef<ItemAsset>> ItemsInBox;
    [FieldOffset(16)]
    public AssetRef<ItemDropBuilderAsset> ItemsInBoxBuilder;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 4787;
        hash = hash * 31 + ItemBoxPrototype.GetHashCode();
        hash = hash * 31 + ItemsInBox.GetHashCode();
        hash = hash * 31 + ItemsInBoxBuilder.GetHashCode();
        return hash;
      }
    }
    public void ClearPointers(FrameBase f, EntityRef entity) {
      if (ItemsInBox != default) f.FreeList(ref ItemsInBox);
    }
    public static void OnRemoved(FrameBase frame, EntityRef entity, void* ptr) {
      var p = (Quantum.ItemBoxSpawnPoint*)ptr;
      p->ClearPointers((Frame)frame, entity);
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (ItemBoxSpawnPoint*)ptr;
        QList.Serialize(&p->ItemsInBox, serializer, Statics.SerializeAssetRef);
        AssetRef.Serialize(&p->ItemBoxPrototype, serializer);
        AssetRef.Serialize(&p->ItemsInBoxBuilder, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  [ExcludeFromPrototype()]
  public unsafe partial struct ItemOutOfUses : Quantum.IComponent {
    public const Int32 SIZE = 4;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    private fixed Byte _alignment_padding_[4];
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 16763;
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (ItemOutOfUses*)ptr;
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  [ExcludeFromPrototype()]
  public unsafe partial struct ItemOwnerIsItemBox : Quantum.IComponent {
    public const Int32 SIZE = 4;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    private fixed Byte _alignment_padding_[4];
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 16073;
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (ItemOwnerIsItemBox*)ptr;
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct ItemOwnerIsSafe : Quantum.IComponent {
    public const Int32 SIZE = 4;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    private fixed Byte _alignment_padding_[4];
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 3299;
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (ItemOwnerIsSafe*)ptr;
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  [ExcludeFromPrototype()]
  public unsafe partial struct ItemOwnerIsUnit : Quantum.IComponent {
    public const Int32 SIZE = 4;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    private fixed Byte _alignment_padding_[4];
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 5051;
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (ItemOwnerIsUnit*)ptr;
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  [ExcludeFromPrototype()]
  public unsafe partial struct ItemOwnerIsWeapon : Quantum.IComponent {
    public const Int32 SIZE = 4;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    private fixed Byte _alignment_padding_[4];
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 431;
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (ItemOwnerIsWeapon*)ptr;
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct KCC : Quantum.IComponent {
    public const Int32 SIZE = 560;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(16)]
    public AssetRef<KCCSettings> Settings;
    [FieldOffset(0)]
    [ExcludeFromPrototype()]
    public QBoolean IsInitialized;
    [FieldOffset(24)]
    [ExcludeFromPrototype()]
    public EntityRef Entity;
    [FieldOffset(32)]
    [ExcludeFromPrototype()]
    public KCCData Data;
    [FieldOffset(4)]
    [ExcludeFromPrototype()]
    public QHashSetPtr<KCCIgnore> Ignores;
    [FieldOffset(12)]
    [ExcludeFromPrototype()]
    public QListPtr<KCCModifier> Modifiers;
    [FieldOffset(8)]
    [ExcludeFromPrototype()]
    public QListPtr<KCCCollision> Collisions;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 659;
        hash = hash * 31 + Settings.GetHashCode();
        hash = hash * 31 + IsInitialized.GetHashCode();
        hash = hash * 31 + Entity.GetHashCode();
        hash = hash * 31 + Data.GetHashCode();
        hash = hash * 31 + Ignores.GetHashCode();
        hash = hash * 31 + Modifiers.GetHashCode();
        hash = hash * 31 + Collisions.GetHashCode();
        return hash;
      }
    }
    public void ClearPointers(FrameBase f, EntityRef entity) {
      Ignores = default;
      Modifiers = default;
      Collisions = default;
    }
    public static void OnRemoved(FrameBase frame, EntityRef entity, void* ptr) {
      var p = (Quantum.KCC*)ptr;
      p->ClearPointers((Frame)frame, entity);
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (KCC*)ptr;
        QBoolean.Serialize(&p->IsInitialized, serializer);
        QHashSet.Serialize(&p->Ignores, serializer, Statics.SerializeKCCIgnore);
        QList.Serialize(&p->Collisions, serializer, Statics.SerializeKCCCollision);
        QList.Serialize(&p->Modifiers, serializer, Statics.SerializeKCCModifier);
        AssetRef.Serialize(&p->Settings, serializer);
        EntityRef.Serialize(&p->Entity, serializer);
        Quantum.KCCData.Serialize(&p->Data, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct KCCProcessorLink : Quantum.IComponent {
    public const Int32 SIZE = 8;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public AssetRef<KCCProcessor> Processor;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 13411;
        hash = hash * 31 + Processor.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (KCCProcessorLink*)ptr;
        AssetRef.Serialize(&p->Processor, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  [ExcludeFromPrototype()]
  public unsafe partial struct LagCompensationProxy : Quantum.IComponent {
    public const Int32 SIZE = 8;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public EntityRef Target;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 4229;
        hash = hash * 31 + Target.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (LagCompensationProxy*)ptr;
        EntityRef.Serialize(&p->Target, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct LagCompensationTarget : Quantum.IComponent {
    public const Int32 SIZE = 2064;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(8)]
    [RequiredRef()]
    public AssetRef<EntityPrototype> ProxyPrototype;
    [FieldOffset(16)]
    [ExcludeFromPrototype()]
    [FramePrinter.FixedArrayAttribute(typeof(Transform3D), 32)]
    private fixed Byte _Buffer_[2048];
    [FieldOffset(0)]
    [ExcludeFromPrototype()]
    public Int32 BufferIndex;
    public readonly FixedArray<Transform3D> Buffer {
      get {
        fixed (byte* p = _Buffer_) { return new FixedArray<Transform3D>(p, 64, 32); }
      }
    }
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 18947;
        hash = hash * 31 + ProxyPrototype.GetHashCode();
        hash = hash * 31 + HashCodeUtils.GetArrayHashCode(Buffer);
        hash = hash * 31 + BufferIndex.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (LagCompensationTarget*)ptr;
        serializer.Stream.Serialize(&p->BufferIndex);
        AssetRef.Serialize(&p->ProxyPrototype, serializer);
        FixedArray.Serialize(p->Buffer, serializer, Statics.SerializeTransform3D);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Mine : Quantum.IComponent {
    public const Int32 SIZE = 120;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(64)]
    [ExcludeFromPrototype()]
    public FP VisibilityDistance;
    [FieldOffset(48)]
    [ExcludeFromPrototype()]
    public FP ExplosionDelay;
    [FieldOffset(56)]
    [ExcludeFromPrototype()]
    public FP ExplosionRadius;
    [FieldOffset(40)]
    [ExcludeFromPrototype()]
    public FP Damage;
    [FieldOffset(16)]
    public AssetRef<EntityPrototype> TriggerAreaPrototype;
    [FieldOffset(24)]
    [ExcludeFromPrototype()]
    public EntityRef Owner;
    [FieldOffset(32)]
    [ExcludeFromPrototype()]
    public EntityRef TriggerAreaEntity;
    [FieldOffset(0)]
    [ExcludeFromPrototype()]
    public QBoolean IsTriggered;
    [FieldOffset(72)]
    [ExcludeFromPrototype()]
    public CountdownTimer ExplosionTimer;
    [FieldOffset(8)]
    [ExcludeFromPrototype()]
    public AssetRef<AttackData> ExplosionAttackData;
    [FieldOffset(96)]
    [ExcludeFromPrototype()]
    public HealthApplicator ExplosionHealthApplicator;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 769;
        hash = hash * 31 + VisibilityDistance.GetHashCode();
        hash = hash * 31 + ExplosionDelay.GetHashCode();
        hash = hash * 31 + ExplosionRadius.GetHashCode();
        hash = hash * 31 + Damage.GetHashCode();
        hash = hash * 31 + TriggerAreaPrototype.GetHashCode();
        hash = hash * 31 + Owner.GetHashCode();
        hash = hash * 31 + TriggerAreaEntity.GetHashCode();
        hash = hash * 31 + IsTriggered.GetHashCode();
        hash = hash * 31 + ExplosionTimer.GetHashCode();
        hash = hash * 31 + ExplosionAttackData.GetHashCode();
        hash = hash * 31 + ExplosionHealthApplicator.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (Mine*)ptr;
        QBoolean.Serialize(&p->IsTriggered, serializer);
        AssetRef.Serialize(&p->ExplosionAttackData, serializer);
        AssetRef.Serialize(&p->TriggerAreaPrototype, serializer);
        EntityRef.Serialize(&p->Owner, serializer);
        EntityRef.Serialize(&p->TriggerAreaEntity, serializer);
        FP.Serialize(&p->Damage, serializer);
        FP.Serialize(&p->ExplosionDelay, serializer);
        FP.Serialize(&p->ExplosionRadius, serializer);
        FP.Serialize(&p->VisibilityDistance, serializer);
        Quantum.CountdownTimer.Serialize(&p->ExplosionTimer, serializer);
        Quantum.HealthApplicator.Serialize(&p->ExplosionHealthApplicator, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct NickName : Quantum.IComponent {
    public const Int32 SIZE = 32;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    public QString32 Value;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 19891;
        hash = hash * 31 + Value.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (NickName*)ptr;
        Quantum.QString32.Serialize(&p->Value, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct ObjectLifetime : Quantum.IComponent {
    public const Int32 SIZE = 24;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public CountdownTimer TTL;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 1693;
        hash = hash * 31 + TTL.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (ObjectLifetime*)ptr;
        Quantum.CountdownTimer.Serialize(&p->TTL, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct OpenedItemBoxMarker : Quantum.IComponent {
    public const Int32 SIZE = 4;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    private fixed Byte _alignment_padding_[4];
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 17341;
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (OpenedItemBoxMarker*)ptr;
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct ParentEntityLink : Quantum.IComponent {
    public const Int32 SIZE = 16;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(8)]
    public EntityRef ParentRef;
    [FieldOffset(0)]
    public QBoolean SyncPosition;
    [FieldOffset(4)]
    public QBoolean SyncRotation;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 653;
        hash = hash * 31 + ParentRef.GetHashCode();
        hash = hash * 31 + SyncPosition.GetHashCode();
        hash = hash * 31 + SyncRotation.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (ParentEntityLink*)ptr;
        QBoolean.Serialize(&p->SyncPosition, serializer);
        QBoolean.Serialize(&p->SyncRotation, serializer);
        EntityRef.Serialize(&p->ParentRef, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct PerceptionMemory : Quantum.IComponent {
    public const Int32 SIZE = 16;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(8)]
    [ExcludeFromPrototype()]
    public AssetRef<BotMemoryModule> MemoryModule;
    [FieldOffset(0)]
    [AllocateOnComponentAdded()]
    [FreeOnComponentRemoved()]
    public QDictionaryPtr<EntityRef, PerceptionMemoryEntry> KnownTargets;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 1459;
        hash = hash * 31 + MemoryModule.GetHashCode();
        hash = hash * 31 + KnownTargets.GetHashCode();
        return hash;
      }
    }
    public void ClearPointers(FrameBase f, EntityRef entity) {
      if (KnownTargets != default) f.FreeDictionary(ref KnownTargets);
    }
    public static void OnRemoved(FrameBase frame, EntityRef entity, void* ptr) {
      var p = (Quantum.PerceptionMemory*)ptr;
      p->ClearPointers((Frame)frame, entity);
    }
    public void AllocatePointers(FrameBase f, EntityRef entity) {
      f.TryAllocateDictionary(ref KnownTargets);
    }
    public static void OnAdded(FrameBase frame, EntityRef entity, void* ptr) {
      var p = (Quantum.PerceptionMemory*)ptr;
      p->AllocatePointers((Frame)frame, entity);
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (PerceptionMemory*)ptr;
        QDictionary.Serialize(&p->KnownTargets, serializer, Statics.SerializeEntityRef, Statics.SerializePerceptionMemoryEntry);
        AssetRef.Serialize(&p->MemoryModule, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct PingPongTarget : Quantum.IComponent {
    public const Int32 SIZE = 72;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public FP Distance;
    [FieldOffset(24)]
    public FPVector3 Direction;
    [FieldOffset(16)]
    public FP Speed;
    [FieldOffset(48)]
    [ExcludeFromPrototype()]
    public FPVector3 Origin;
    [FieldOffset(8)]
    [ExcludeFromPrototype()]
    public FP Phase;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 15233;
        hash = hash * 31 + Distance.GetHashCode();
        hash = hash * 31 + Direction.GetHashCode();
        hash = hash * 31 + Speed.GetHashCode();
        hash = hash * 31 + Origin.GetHashCode();
        hash = hash * 31 + Phase.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (PingPongTarget*)ptr;
        FP.Serialize(&p->Distance, serializer);
        FP.Serialize(&p->Phase, serializer);
        FP.Serialize(&p->Speed, serializer);
        FPVector3.Serialize(&p->Direction, serializer);
        FPVector3.Serialize(&p->Origin, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct ReconEffect : Quantum.IComponent {
    public const Int32 SIZE = 56;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(32)]
    public FPVector3 Position;
    [FieldOffset(16)]
    public FP Radius;
    [FieldOffset(8)]
    public FP Duration;
    [FieldOffset(24)]
    public FP StartTime;
    [FieldOffset(0)]
    public EntityRef OwnerRef;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 21247;
        hash = hash * 31 + Position.GetHashCode();
        hash = hash * 31 + Radius.GetHashCode();
        hash = hash * 31 + Duration.GetHashCode();
        hash = hash * 31 + StartTime.GetHashCode();
        hash = hash * 31 + OwnerRef.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (ReconEffect*)ptr;
        EntityRef.Serialize(&p->OwnerRef, serializer);
        FP.Serialize(&p->Duration, serializer);
        FP.Serialize(&p->Radius, serializer);
        FP.Serialize(&p->StartTime, serializer);
        FPVector3.Serialize(&p->Position, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct SlowDebuff : Quantum.IComponent {
    public const Int32 SIZE = 32;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public Int32 hitCount;
    [FieldOffset(4)]
    public Int32 hitLimit;
    [FieldOffset(8)]
    public Int32 priority;
    [FieldOffset(16)]
    public FP slowMultiplier;
    [FieldOffset(24)]
    public FP timer;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 10979;
        hash = hash * 31 + hitCount.GetHashCode();
        hash = hash * 31 + hitLimit.GetHashCode();
        hash = hash * 31 + priority.GetHashCode();
        hash = hash * 31 + slowMultiplier.GetHashCode();
        hash = hash * 31 + timer.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (SlowDebuff*)ptr;
        serializer.Stream.Serialize(&p->hitCount);
        serializer.Stream.Serialize(&p->hitLimit);
        serializer.Stream.Serialize(&p->priority);
        FP.Serialize(&p->slowMultiplier, serializer);
        FP.Serialize(&p->timer, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct SpawnPoint : Quantum.IComponent {
    public const Int32 SIZE = 96;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public Byte ID;
    [FieldOffset(80)]
    [RequiredRef()]
    [Header("  !       :")]
    public EntityRef exitZoneRef;
    [FieldOffset(88)]
    [RequiredRef()]
    [Header("   !     Way")]
    public EntityRef wayRef;
    [FieldOffset(8)]
    [Header(" ")]
    public AssetRef<BotDifficultiesConfig> StatsMultipliersOverride;
    [FieldOffset(72)]
    [Header("Loadout  BT")]
    public AssetRef<LoadoutConfig> LoadoutOverride;
    [FieldOffset(64)]
    public AssetRef<BTRoot> TreeOverride;
    [FieldOffset(56)]
    [Header("Perception modules")]
    public AssetRef<BotVisionModule> VisionModuleOverride;
    [FieldOffset(16)]
    public AssetRef<BotHearingModule> HearingModuleOverride;
    [FieldOffset(24)]
    public AssetRef<BotMemoryModule> MemoryModuleOverride;
    [FieldOffset(48)]
    [Header("State configs")]
    public AssetRef<BotStatePatrol> PatrolStateOverride;
    [FieldOffset(32)]
    public AssetRef<BotStateAlert> AlertStateOverride;
    [FieldOffset(40)]
    public AssetRef<BotStateCombat> CombatStateOverride;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 12269;
        hash = hash * 31 + ID.GetHashCode();
        hash = hash * 31 + exitZoneRef.GetHashCode();
        hash = hash * 31 + wayRef.GetHashCode();
        hash = hash * 31 + StatsMultipliersOverride.GetHashCode();
        hash = hash * 31 + LoadoutOverride.GetHashCode();
        hash = hash * 31 + TreeOverride.GetHashCode();
        hash = hash * 31 + VisionModuleOverride.GetHashCode();
        hash = hash * 31 + HearingModuleOverride.GetHashCode();
        hash = hash * 31 + MemoryModuleOverride.GetHashCode();
        hash = hash * 31 + PatrolStateOverride.GetHashCode();
        hash = hash * 31 + AlertStateOverride.GetHashCode();
        hash = hash * 31 + CombatStateOverride.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (SpawnPoint*)ptr;
        serializer.Stream.Serialize(&p->ID);
        AssetRef.Serialize(&p->StatsMultipliersOverride, serializer);
        AssetRef.Serialize(&p->HearingModuleOverride, serializer);
        AssetRef.Serialize(&p->MemoryModuleOverride, serializer);
        AssetRef.Serialize(&p->AlertStateOverride, serializer);
        AssetRef.Serialize(&p->CombatStateOverride, serializer);
        AssetRef.Serialize(&p->PatrolStateOverride, serializer);
        AssetRef.Serialize(&p->VisionModuleOverride, serializer);
        AssetRef.Serialize(&p->TreeOverride, serializer);
        AssetRef.Serialize(&p->LoadoutOverride, serializer);
        EntityRef.Serialize(&p->exitZoneRef, serializer);
        EntityRef.Serialize(&p->wayRef, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Team : Quantum.IComponent {
    public const Int32 SIZE = 4;
    public const Int32 ALIGNMENT = 1;
    [FieldOffset(1)]
    private fixed Byte _alignment_padding_[3];
    [FieldOffset(0)]
    public Byte Index;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 3719;
        hash = hash * 31 + Index.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (Team*)ptr;
        serializer.Stream.Serialize(&p->Index);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct TimerItemBoxMarker : Quantum.IComponent {
    public const Int32 SIZE = 4;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    private fixed Byte _alignment_padding_[4];
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 14033;
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (TimerItemBoxMarker*)ptr;
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct TriggerArea : Quantum.IComponent {
    public const Int32 SIZE = 16;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    [ExcludeFromPrototype()]
    [AllocateOnComponentAdded()]
    [FreeOnComponentRemoved()]
    public QHashSetPtr<EntityRef> EntitiesInside;
    [FieldOffset(8)]
    [ExcludeFromPrototype()]
    public EntityRef SelfEntity;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 8599;
        hash = hash * 31 + EntitiesInside.GetHashCode();
        hash = hash * 31 + SelfEntity.GetHashCode();
        return hash;
      }
    }
    public void ClearPointers(FrameBase f, EntityRef entity) {
      if (EntitiesInside != default) f.FreeHashSet(ref EntitiesInside);
    }
    public static void OnRemoved(FrameBase frame, EntityRef entity, void* ptr) {
      var p = (Quantum.TriggerArea*)ptr;
      p->ClearPointers((Frame)frame, entity);
    }
    public void AllocatePointers(FrameBase f, EntityRef entity) {
      f.TryAllocateHashSet(ref EntitiesInside);
    }
    public static void OnAdded(FrameBase frame, EntityRef entity, void* ptr) {
      var p = (Quantum.TriggerArea*)ptr;
      p->AllocatePointers((Frame)frame, entity);
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (TriggerArea*)ptr;
        QHashSet.Serialize(&p->EntitiesInside, serializer, Statics.SerializeEntityRef);
        EntityRef.Serialize(&p->SelfEntity, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  [ExcludeFromPrototype()]
  public unsafe partial struct TriggerAreaWithEntities : Quantum.IComponent {
    public const Int32 SIZE = 4;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    private fixed Byte _alignment_padding_[4];
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 2927;
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (TriggerAreaWithEntities*)ptr;
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Turret : Quantum.IComponent {
    public const Int32 SIZE = 56;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(48)]
    public FP RotationAnglesPerSecond;
    [FieldOffset(40)]
    public FP AttackZoneAngles;
    [FieldOffset(0)]
    [Header("      ")]
    public AssetRef<EntityPrototype> TriggerAreaPrototype;
    [FieldOffset(8)]
    public AssetRef<WeaponItemAsset> WeaponConfig;
    [FieldOffset(24)]
    [ExcludeFromPrototype()]
    public EntityRef Owner;
    [FieldOffset(32)]
    [ExcludeFromPrototype()]
    public EntityRef TriggerAreaEntity;
    [FieldOffset(16)]
    [ExcludeFromPrototype()]
    public EntityRef CurrentTarget;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 4447;
        hash = hash * 31 + RotationAnglesPerSecond.GetHashCode();
        hash = hash * 31 + AttackZoneAngles.GetHashCode();
        hash = hash * 31 + TriggerAreaPrototype.GetHashCode();
        hash = hash * 31 + WeaponConfig.GetHashCode();
        hash = hash * 31 + Owner.GetHashCode();
        hash = hash * 31 + TriggerAreaEntity.GetHashCode();
        hash = hash * 31 + CurrentTarget.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (Turret*)ptr;
        AssetRef.Serialize(&p->TriggerAreaPrototype, serializer);
        AssetRef.Serialize(&p->WeaponConfig, serializer);
        EntityRef.Serialize(&p->CurrentTarget, serializer);
        EntityRef.Serialize(&p->Owner, serializer);
        EntityRef.Serialize(&p->TriggerAreaEntity, serializer);
        FP.Serialize(&p->AttackZoneAngles, serializer);
        FP.Serialize(&p->RotationAnglesPerSecond, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Unit : Quantum.IComponent {
    public const Int32 SIZE = 560;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(32)]
    [RequiredRef()]
    public AssetRef<UnitAsset> Asset;
    [FieldOffset(8)]
    [ExcludeFromPrototype()]
    public PlayerRef PlayerRef;
    [FieldOffset(160)]
    [ExcludeFromPrototype()]
    public FP WeaponAimSecondsElapsed;
    [FieldOffset(48)]
    [ExcludeFromPrototype()]
    public EntityRef ActiveWeaponRef;
    [FieldOffset(96)]
    [ExcludeFromPrototype()]
    public EntityRef PrimaryWeapon;
    [FieldOffset(104)]
    [ExcludeFromPrototype()]
    public EntityRef SecondaryWeapon;
    [FieldOffset(56)]
    [ExcludeFromPrototype()]
    public EntityRef MeleeWeapon;
    [FieldOffset(112)]
    [ExcludeFromPrototype()]
    public EntityRef Skin;
    [FieldOffset(24)]
    [ExcludeFromPrototype()]
    public WeaponSlot ActiveWeaponSlot;
    [FieldOffset(28)]
    [ExcludeFromPrototype()]
    public WeaponSlot PrevWeaponSlot;
    [FieldOffset(40)]
    [ExcludeFromPrototype()]
    public EntityRef AbilityRef;
    [FieldOffset(232)]
    [ExcludeFromPrototype()]
    public ActiveAbilityInfo ActiveAbilityInfo;
    [FieldOffset(12)]
    [ExcludeFromPrototype()]
    public QBoolean Aiming;
    [FieldOffset(16)]
    [ExcludeFromPrototype()]
    public QBoolean HasTarget;
    [FieldOffset(20)]
    [ExcludeFromPrototype()]
    public QBoolean IsTargetBlocked;
    [FieldOffset(120)]
    [ExcludeFromPrototype()]
    public EntityRef Target;
    [FieldOffset(208)]
    [ExcludeFromPrototype()]
    public FPVector3 TargetPositionLagCompensated;
    [FieldOffset(152)]
    [ExcludeFromPrototype()]
    public FP HideWeaponTimer;
    [FieldOffset(144)]
    [ExcludeFromPrototype()]
    public FP GetWeaponTimer;
    [FieldOffset(88)]
    [ExcludeFromPrototype()]
    public EntityRef PrevWeaponRef;
    [FieldOffset(80)]
    [ExcludeFromPrototype()]
    public EntityRef NearbyItemBox;
    [FieldOffset(64)]
    [ExcludeFromPrototype()]
    public EntityRef NearbyBackpack;
    [FieldOffset(72)]
    [ExcludeFromPrototype()]
    public EntityRef NearbyInteractiveZone;
    [FieldOffset(128)]
    [ExcludeFromPrototype()]
    public EntityRef TargetExitZone;
    [FieldOffset(184)]
    [ExcludeFromPrototype()]
    public CountdownTimer ExitZoneTimer;
    [FieldOffset(320)]
    [ExcludeFromPrototype()]
    public UnitStats CurrentStats;
    [FieldOffset(0)]
    [ExcludeFromPrototype()]
    public Int32 Frags;
    [FieldOffset(136)]
    [ExcludeFromPrototype()]
    public FP CurrentSpeed;
    [FieldOffset(168)]
    [ExcludeFromPrototype()]
    public RNGSession RNG;
    [FieldOffset(4)]
    [ExcludeFromPrototype()]
    public Int32 LastLagCompensatedFrame;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 6367;
        hash = hash * 31 + Asset.GetHashCode();
        hash = hash * 31 + PlayerRef.GetHashCode();
        hash = hash * 31 + WeaponAimSecondsElapsed.GetHashCode();
        hash = hash * 31 + ActiveWeaponRef.GetHashCode();
        hash = hash * 31 + PrimaryWeapon.GetHashCode();
        hash = hash * 31 + SecondaryWeapon.GetHashCode();
        hash = hash * 31 + MeleeWeapon.GetHashCode();
        hash = hash * 31 + Skin.GetHashCode();
        hash = hash * 31 + (Int32)ActiveWeaponSlot;
        hash = hash * 31 + (Int32)PrevWeaponSlot;
        hash = hash * 31 + AbilityRef.GetHashCode();
        hash = hash * 31 + ActiveAbilityInfo.GetHashCode();
        hash = hash * 31 + Aiming.GetHashCode();
        hash = hash * 31 + HasTarget.GetHashCode();
        hash = hash * 31 + IsTargetBlocked.GetHashCode();
        hash = hash * 31 + Target.GetHashCode();
        hash = hash * 31 + TargetPositionLagCompensated.GetHashCode();
        hash = hash * 31 + HideWeaponTimer.GetHashCode();
        hash = hash * 31 + GetWeaponTimer.GetHashCode();
        hash = hash * 31 + PrevWeaponRef.GetHashCode();
        hash = hash * 31 + NearbyItemBox.GetHashCode();
        hash = hash * 31 + NearbyBackpack.GetHashCode();
        hash = hash * 31 + NearbyInteractiveZone.GetHashCode();
        hash = hash * 31 + TargetExitZone.GetHashCode();
        hash = hash * 31 + ExitZoneTimer.GetHashCode();
        hash = hash * 31 + CurrentStats.GetHashCode();
        hash = hash * 31 + Frags.GetHashCode();
        hash = hash * 31 + CurrentSpeed.GetHashCode();
        hash = hash * 31 + RNG.GetHashCode();
        hash = hash * 31 + LastLagCompensatedFrame.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (Unit*)ptr;
        serializer.Stream.Serialize(&p->Frags);
        serializer.Stream.Serialize(&p->LastLagCompensatedFrame);
        PlayerRef.Serialize(&p->PlayerRef, serializer);
        QBoolean.Serialize(&p->Aiming, serializer);
        QBoolean.Serialize(&p->HasTarget, serializer);
        QBoolean.Serialize(&p->IsTargetBlocked, serializer);
        serializer.Stream.Serialize((Int32*)&p->ActiveWeaponSlot);
        serializer.Stream.Serialize((Int32*)&p->PrevWeaponSlot);
        AssetRef.Serialize(&p->Asset, serializer);
        EntityRef.Serialize(&p->AbilityRef, serializer);
        EntityRef.Serialize(&p->ActiveWeaponRef, serializer);
        EntityRef.Serialize(&p->MeleeWeapon, serializer);
        EntityRef.Serialize(&p->NearbyBackpack, serializer);
        EntityRef.Serialize(&p->NearbyInteractiveZone, serializer);
        EntityRef.Serialize(&p->NearbyItemBox, serializer);
        EntityRef.Serialize(&p->PrevWeaponRef, serializer);
        EntityRef.Serialize(&p->PrimaryWeapon, serializer);
        EntityRef.Serialize(&p->SecondaryWeapon, serializer);
        EntityRef.Serialize(&p->Skin, serializer);
        EntityRef.Serialize(&p->Target, serializer);
        EntityRef.Serialize(&p->TargetExitZone, serializer);
        FP.Serialize(&p->CurrentSpeed, serializer);
        FP.Serialize(&p->GetWeaponTimer, serializer);
        FP.Serialize(&p->HideWeaponTimer, serializer);
        FP.Serialize(&p->WeaponAimSecondsElapsed, serializer);
        RNGSession.Serialize(&p->RNG, serializer);
        Quantum.CountdownTimer.Serialize(&p->ExitZoneTimer, serializer);
        FPVector3.Serialize(&p->TargetPositionLagCompensated, serializer);
        Quantum.ActiveAbilityInfo.Serialize(&p->ActiveAbilityInfo, serializer);
        Quantum.UnitStats.Serialize(&p->CurrentStats, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct UnitAim : Quantum.IComponent {
    public const Int32 SIZE = 104;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    [ExcludeFromPrototype()]
    public EntityRef AimEntity;
    [FieldOffset(80)]
    [ExcludeFromPrototype()]
    public FPYawPitchRoll AimCurrentRotation;
    [FieldOffset(56)]
    [ExcludeFromPrototype()]
    public FPVector3 AimCurrentRotationVelocity;
    [FieldOffset(8)]
    [ExcludeFromPrototype()]
    public FPVector3 AimCurrentPosition;
    [FieldOffset(32)]
    [ExcludeFromPrototype()]
    public FPVector3 AimCurrentPositionVelocity;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 2633;
        hash = hash * 31 + AimEntity.GetHashCode();
        hash = hash * 31 + AimCurrentRotation.GetHashCode();
        hash = hash * 31 + AimCurrentRotationVelocity.GetHashCode();
        hash = hash * 31 + AimCurrentPosition.GetHashCode();
        hash = hash * 31 + AimCurrentPositionVelocity.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (UnitAim*)ptr;
        EntityRef.Serialize(&p->AimEntity, serializer);
        FPVector3.Serialize(&p->AimCurrentPosition, serializer);
        FPVector3.Serialize(&p->AimCurrentPositionVelocity, serializer);
        FPVector3.Serialize(&p->AimCurrentRotationVelocity, serializer);
        Quantum.FPYawPitchRoll.Serialize(&p->AimCurrentRotation, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct UnitDestroyOnDead : Quantum.IComponent {
    public const Int32 SIZE = 8;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public FP Timer;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 18803;
        hash = hash * 31 + Timer.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (UnitDestroyOnDead*)ptr;
        FP.Serialize(&p->Timer, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  [ExcludeFromPrototype()]
  public unsafe partial struct UnitExited : Quantum.IComponent {
    public const Int32 SIZE = 4;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    private fixed Byte _alignment_padding_[4];
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 5839;
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (UnitExited*)ptr;
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct UnitFeatureDropLoadoutOnDeath : Quantum.IComponent {
    public const Int32 SIZE = 4;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    private fixed Byte _alignment_padding_[4];
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 8539;
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (UnitFeatureDropLoadoutOnDeath*)ptr;
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct UnitFeatureHealSelfOnDeath : Quantum.IComponent {
    public const Int32 SIZE = 56;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public FP HealDelaySeconds;
    [FieldOffset(32)]
    public HealthApplicator Applicator;
    [FieldOffset(8)]
    [ExcludeFromPrototype()]
    public CountdownTimer RespawnTimer;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 12979;
        hash = hash * 31 + HealDelaySeconds.GetHashCode();
        hash = hash * 31 + Applicator.GetHashCode();
        hash = hash * 31 + RespawnTimer.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (UnitFeatureHealSelfOnDeath*)ptr;
        FP.Serialize(&p->HealDelaySeconds, serializer);
        Quantum.CountdownTimer.Serialize(&p->RespawnTimer, serializer);
        Quantum.HealthApplicator.Serialize(&p->Applicator, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  [ExcludeFromPrototype()]
  public unsafe partial struct UnitFeatureSprintWithStamina : Quantum.IComponent {
    public const Int32 SIZE = 16;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public FP current;
    [FieldOffset(8)]
    public FP regenTimer;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 12967;
        hash = hash * 31 + current.GetHashCode();
        hash = hash * 31 + regenTimer.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (UnitFeatureSprintWithStamina*)ptr;
        FP.Serialize(&p->current, serializer);
        FP.Serialize(&p->regenTimer, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Vision : Quantum.IComponent {
    public const Int32 SIZE = 96;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(48)]
    public VisibilityArea VisibilityForwardArea;
    [FieldOffset(24)]
    public VisibilityArea Visibility360Area;
    [FieldOffset(72)]
    [ExcludeFromPrototype()]
    public VisibilityArea WeaponVisibilityArea;
    [FieldOffset(16)]
    [ExcludeFromPrototype()]
    public EntityRef InvisibilityZone;
    [FieldOffset(0)]
    [ExcludeFromPrototype()]
    public QBoolean IsForceVisibleInInvisibilityZone_Out;
    [FieldOffset(8)]
    [ExcludeFromPrototype()]
    public QBoolean IsVisibleByAnyEnemy_Out;
    [FieldOffset(4)]
    [ExcludeFromPrototype()]
    public QBoolean IsInAim_Out;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 4027;
        hash = hash * 31 + VisibilityForwardArea.GetHashCode();
        hash = hash * 31 + Visibility360Area.GetHashCode();
        hash = hash * 31 + WeaponVisibilityArea.GetHashCode();
        hash = hash * 31 + InvisibilityZone.GetHashCode();
        hash = hash * 31 + IsForceVisibleInInvisibilityZone_Out.GetHashCode();
        hash = hash * 31 + IsVisibleByAnyEnemy_Out.GetHashCode();
        hash = hash * 31 + IsInAim_Out.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (Vision*)ptr;
        QBoolean.Serialize(&p->IsForceVisibleInInvisibilityZone_Out, serializer);
        QBoolean.Serialize(&p->IsInAim_Out, serializer);
        QBoolean.Serialize(&p->IsVisibleByAnyEnemy_Out, serializer);
        EntityRef.Serialize(&p->InvisibilityZone, serializer);
        Quantum.VisibilityArea.Serialize(&p->Visibility360Area, serializer);
        Quantum.VisibilityArea.Serialize(&p->VisibilityForwardArea, serializer);
        Quantum.VisibilityArea.Serialize(&p->WeaponVisibilityArea, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Way : Quantum.IComponent {
    public const Int32 SIZE = 8;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    public Byte id;
    [FieldOffset(4)]
    [AllocateOnComponentAdded()]
    [FreeOnComponentRemoved()]
    public QListPtr<FPVector3> Points;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 4759;
        hash = hash * 31 + id.GetHashCode();
        hash = hash * 31 + Points.GetHashCode();
        return hash;
      }
    }
    public void ClearPointers(FrameBase f, EntityRef entity) {
      if (Points != default) f.FreeList(ref Points);
    }
    public static void OnRemoved(FrameBase frame, EntityRef entity, void* ptr) {
      var p = (Quantum.Way*)ptr;
      p->ClearPointers((Frame)frame, entity);
    }
    public void AllocatePointers(FrameBase f, EntityRef entity) {
      f.TryAllocateList(ref Points);
    }
    public static void OnAdded(FrameBase frame, EntityRef entity, void* ptr) {
      var p = (Quantum.Way*)ptr;
      p->AllocatePointers((Frame)frame, entity);
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (Way*)ptr;
        serializer.Stream.Serialize(&p->id);
        QList.Serialize(&p->Points, serializer, Statics.SerializeFPVector3);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Weapon : Quantum.IComponent {
    public const Int32 SIZE = 376;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(16)]
    [ExcludeFromPrototype()]
    public FP ReloadingTimer;
    [FieldOffset(40)]
    [ExcludeFromPrototype()]
    public FrameTimer PreReloadingTimer;
    [FieldOffset(32)]
    [ExcludeFromPrototype()]
    public FrameTimer FireRateTimer;
    [FieldOffset(8)]
    [ExcludeFromPrototype()]
    public AssetRef<WeaponItemAsset> Config;
    [FieldOffset(0)]
    [ExcludeFromPrototype()]
    public Int16 BulletsCount;
    [FieldOffset(48)]
    [ExcludeFromPrototype()]
    public WeaponStats CurrentStats;
    [FieldOffset(24)]
    [ExcludeFromPrototype()]
    public FP currentShootingSpread;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 8713;
        hash = hash * 31 + ReloadingTimer.GetHashCode();
        hash = hash * 31 + PreReloadingTimer.GetHashCode();
        hash = hash * 31 + FireRateTimer.GetHashCode();
        hash = hash * 31 + Config.GetHashCode();
        hash = hash * 31 + BulletsCount.GetHashCode();
        hash = hash * 31 + CurrentStats.GetHashCode();
        hash = hash * 31 + currentShootingSpread.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (Weapon*)ptr;
        serializer.Stream.Serialize(&p->BulletsCount);
        AssetRef.Serialize(&p->Config, serializer);
        FP.Serialize(&p->ReloadingTimer, serializer);
        FP.Serialize(&p->currentShootingSpread, serializer);
        FrameTimer.Serialize(&p->FireRateTimer, serializer);
        FrameTimer.Serialize(&p->PreReloadingTimer, serializer);
        Quantum.WeaponStats.Serialize(&p->CurrentStats, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct WeaponAttack : Quantum.IComponent {
    public const Int32 SIZE = 8;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public AssetRef<WeaponItemAsset> WeaponConfig;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 9883;
        hash = hash * 31 + WeaponConfig.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (WeaponAttack*)ptr;
        AssetRef.Serialize(&p->WeaponConfig, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct WeaponItem : Quantum.IComponent {
    public const Int32 SIZE = 72;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public EntityRef SelfWeaponEntity;
    [FieldOffset(8)]
    [FramePrinter.FixedArrayAttribute(typeof(EntityRef), 8)]
    private fixed Byte _WeaponAttachmentsRaw_[64];
    public readonly FixedArray<EntityRef> WeaponAttachmentsRaw {
      get {
        fixed (byte* p = _WeaponAttachmentsRaw_) { return new FixedArray<EntityRef>(p, 8, 8); }
      }
    }
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 12487;
        hash = hash * 31 + SelfWeaponEntity.GetHashCode();
        hash = hash * 31 + HashCodeUtils.GetArrayHashCode(WeaponAttachmentsRaw);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (WeaponItem*)ptr;
        EntityRef.Serialize(&p->SelfWeaponEntity, serializer);
        FixedArray.Serialize(p->WeaponAttachmentsRaw, serializer, Statics.SerializeEntityRef);
    }
  }
  public unsafe partial interface ISignalOnCooldownsReset : ISignal {
    void OnCooldownsReset(Frame f, EntityRef playerEntityRef);
  }
  public unsafe partial interface ISignalOnActiveAbilityStopped : ISignal {
    void OnActiveAbilityStopped(Frame f, EntityRef playerEntityRef);
  }
  public unsafe partial interface ISignalOnCreateAttack : ISignal {
    void OnCreateAttack(Frame f, EntityRef attackEntity, Attack* attack);
  }
  public unsafe partial interface ISignalOnDisableAttack : ISignal {
    void OnDisableAttack(Frame f, EntityRef attackEntity);
  }
  public unsafe partial interface ISignalOnCharacterBeforeLoadoutSlotUnassigned : ISignal {
    void OnCharacterBeforeLoadoutSlotUnassigned(Frame f, EntityRef characterEntity, CharacterLoadoutSlots slot, EntityRef itemEntity);
  }
  public unsafe partial interface ISignalOnCharacterAfterLoadoutSlotAssigned : ISignal {
    void OnCharacterAfterLoadoutSlotAssigned(Frame f, EntityRef characterEntity, CharacterLoadoutSlots slot, EntityRef itemEntity);
  }
  public unsafe partial interface ISignalOnSafeChanged : ISignal {
    void OnSafeChanged(Frame f, EntityRef owner, SafeChangeKind change, EntityRef itemEntity);
  }
  public unsafe partial interface ISignalOnSafeResized : ISignal {
    void OnSafeResized(Frame f, EntityRef owner, Int32 width, Int32 height);
  }
  public unsafe partial interface ISignalOnExitZoneUsed : ISignal {
    void OnExitZoneUsed(Frame f, Int32 photonActorId);
  }
  public unsafe partial interface ISignalOnPresentationStart : ISignal {
    void OnPresentationStart(Frame f);
  }
  public unsafe partial interface ISignalOnGameStart : ISignal {
    void OnGameStart(Frame f);
  }
  public unsafe partial interface ISignalOnGameEnd : ISignal {
    void OnGameEnd(Frame f);
  }
  public unsafe partial interface ISignalOnOpenItemBox : ISignal {
    void OnOpenItemBox(Frame f, EntityRef itemBoxRef);
  }
  public unsafe partial interface ISignalOnMineTrigger : ISignal {
    void OnMineTrigger(Frame f, EntityRef mineRef);
  }
  public unsafe partial interface ISignalOnUnitSpawn : ISignal {
    void OnUnitSpawn(Frame f, EntityRef e);
  }
  public unsafe partial interface ISignalOnUnitDead : ISignal {
    void OnUnitDead(Frame f, EntityRef e);
  }
  public unsafe partial interface ISignalOnUnitDamage : ISignal {
    void OnUnitDamage(Frame f, EntityRef source, EntityRef target, FP value);
  }
  public unsafe partial interface ISignalOnUnitHeal : ISignal {
    void OnUnitHeal(Frame f, EntityRef source, EntityRef target, FP value);
  }
  public unsafe partial interface ISignalOnUnitHideWeapon : ISignal {
    void OnUnitHideWeapon(Frame f, EntityRef unitRef);
  }
  public unsafe partial interface ISignalOnUnitGetWeapon : ISignal {
    void OnUnitGetWeapon(Frame f, EntityRef unitRef);
  }
  public unsafe partial interface ISignalOnEquipWeapon : ISignal {
    void OnEquipWeapon(Frame f, EntityRef e);
  }
  public unsafe partial interface ISignalOnReloading : ISignal {
    void OnReloading(Frame f, EntityRef attackerRef, EntityRef weaponRef);
  }
  public unsafe partial interface ISignalOnCreateShoot : ISignal {
    void OnCreateShoot(Frame f, EntityRef unitRef, EntityRef weaponRef, Weapon* weapon);
  }
  public static unsafe partial class QConstants {
    public const Int32 CHARACTER_LOADOUT_SLOTS = 14;
    public const Int32 MAX_AIM_DISTANCE = 10;
    public const Int32 INPUT_MAX_MAGNITUDE = 1;
    public const Int32 MAX_TEAM_SIZE = 3;
    public const Int32 WEAPON_ATTACHMENT_SLOTS = 8;
  }
  public unsafe partial class Frame {
    private ISignalOnCooldownsReset[] _ISignalOnCooldownsResetSystems;
    private ISignalOnActiveAbilityStopped[] _ISignalOnActiveAbilityStoppedSystems;
    private ISignalOnCreateAttack[] _ISignalOnCreateAttackSystems;
    private ISignalOnDisableAttack[] _ISignalOnDisableAttackSystems;
    private ISignalOnCharacterBeforeLoadoutSlotUnassigned[] _ISignalOnCharacterBeforeLoadoutSlotUnassignedSystems;
    private ISignalOnCharacterAfterLoadoutSlotAssigned[] _ISignalOnCharacterAfterLoadoutSlotAssignedSystems;
    private ISignalOnSafeChanged[] _ISignalOnSafeChangedSystems;
    private ISignalOnSafeResized[] _ISignalOnSafeResizedSystems;
    private ISignalOnExitZoneUsed[] _ISignalOnExitZoneUsedSystems;
    private ISignalOnPresentationStart[] _ISignalOnPresentationStartSystems;
    private ISignalOnGameStart[] _ISignalOnGameStartSystems;
    private ISignalOnGameEnd[] _ISignalOnGameEndSystems;
    private ISignalOnOpenItemBox[] _ISignalOnOpenItemBoxSystems;
    private ISignalOnMineTrigger[] _ISignalOnMineTriggerSystems;
    private ISignalOnUnitSpawn[] _ISignalOnUnitSpawnSystems;
    private ISignalOnUnitDead[] _ISignalOnUnitDeadSystems;
    private ISignalOnUnitDamage[] _ISignalOnUnitDamageSystems;
    private ISignalOnUnitHeal[] _ISignalOnUnitHealSystems;
    private ISignalOnUnitHideWeapon[] _ISignalOnUnitHideWeaponSystems;
    private ISignalOnUnitGetWeapon[] _ISignalOnUnitGetWeaponSystems;
    private ISignalOnEquipWeapon[] _ISignalOnEquipWeaponSystems;
    private ISignalOnReloading[] _ISignalOnReloadingSystems;
    private ISignalOnCreateShoot[] _ISignalOnCreateShootSystems;
    partial void AllocGen() {
      _globals = (_globals_*)Context.Allocator.AllocAndClear(sizeof(_globals_));
    }
    partial void FreeGen() {
      Context.Allocator.Free(_globals);
    }
    partial void CopyFromGen(Frame frame) {
      Native.Utils.Copy(_globals, frame._globals, sizeof(_globals_));
    }
    partial void InitGen() {
      Initialize(this, this.SimulationConfig.Entities, 256);
      _ISignalOnCooldownsResetSystems = BuildSignalsArray<ISignalOnCooldownsReset>();
      _ISignalOnActiveAbilityStoppedSystems = BuildSignalsArray<ISignalOnActiveAbilityStopped>();
      _ISignalOnCreateAttackSystems = BuildSignalsArray<ISignalOnCreateAttack>();
      _ISignalOnDisableAttackSystems = BuildSignalsArray<ISignalOnDisableAttack>();
      _ISignalOnCharacterBeforeLoadoutSlotUnassignedSystems = BuildSignalsArray<ISignalOnCharacterBeforeLoadoutSlotUnassigned>();
      _ISignalOnCharacterAfterLoadoutSlotAssignedSystems = BuildSignalsArray<ISignalOnCharacterAfterLoadoutSlotAssigned>();
      _ISignalOnSafeChangedSystems = BuildSignalsArray<ISignalOnSafeChanged>();
      _ISignalOnSafeResizedSystems = BuildSignalsArray<ISignalOnSafeResized>();
      _ISignalOnExitZoneUsedSystems = BuildSignalsArray<ISignalOnExitZoneUsed>();
      _ISignalOnPresentationStartSystems = BuildSignalsArray<ISignalOnPresentationStart>();
      _ISignalOnGameStartSystems = BuildSignalsArray<ISignalOnGameStart>();
      _ISignalOnGameEndSystems = BuildSignalsArray<ISignalOnGameEnd>();
      _ISignalOnOpenItemBoxSystems = BuildSignalsArray<ISignalOnOpenItemBox>();
      _ISignalOnMineTriggerSystems = BuildSignalsArray<ISignalOnMineTrigger>();
      _ISignalOnUnitSpawnSystems = BuildSignalsArray<ISignalOnUnitSpawn>();
      _ISignalOnUnitDeadSystems = BuildSignalsArray<ISignalOnUnitDead>();
      _ISignalOnUnitDamageSystems = BuildSignalsArray<ISignalOnUnitDamage>();
      _ISignalOnUnitHealSystems = BuildSignalsArray<ISignalOnUnitHeal>();
      _ISignalOnUnitHideWeaponSystems = BuildSignalsArray<ISignalOnUnitHideWeapon>();
      _ISignalOnUnitGetWeaponSystems = BuildSignalsArray<ISignalOnUnitGetWeapon>();
      _ISignalOnEquipWeaponSystems = BuildSignalsArray<ISignalOnEquipWeapon>();
      _ISignalOnReloadingSystems = BuildSignalsArray<ISignalOnReloading>();
      _ISignalOnCreateShootSystems = BuildSignalsArray<ISignalOnCreateShoot>();
      _ComponentSignalsOnAdded = new ComponentReactiveCallbackInvoker[ComponentTypeId.Type.Length];
      _ComponentSignalsOnRemoved = new ComponentReactiveCallbackInvoker[ComponentTypeId.Type.Length];
      BuildSignalsArrayOnComponentAdded<AIBlackboardComponent>();
      BuildSignalsArrayOnComponentRemoved<AIBlackboardComponent>();
      BuildSignalsArrayOnComponentAdded<Quantum.Ability>();
      BuildSignalsArrayOnComponentRemoved<Quantum.Ability>();
      BuildSignalsArrayOnComponentAdded<Quantum.AnimationTriggers>();
      BuildSignalsArrayOnComponentRemoved<Quantum.AnimationTriggers>();
      BuildSignalsArrayOnComponentAdded<Quantum.Attack>();
      BuildSignalsArrayOnComponentRemoved<Quantum.Attack>();
      BuildSignalsArrayOnComponentAdded<Quantum.Attributes>();
      BuildSignalsArrayOnComponentRemoved<Quantum.Attributes>();
      BuildSignalsArrayOnComponentAdded<Quantum.AttributesTickable>();
      BuildSignalsArrayOnComponentRemoved<Quantum.AttributesTickable>();
      BuildSignalsArrayOnComponentAdded<BTAgent>();
      BuildSignalsArrayOnComponentRemoved<BTAgent>();
      BuildSignalsArrayOnComponentAdded<Quantum.Bot>();
      BuildSignalsArrayOnComponentRemoved<Quantum.Bot>();
      BuildSignalsArrayOnComponentAdded<Quantum.BotInvisibleByPlayer>();
      BuildSignalsArrayOnComponentRemoved<Quantum.BotInvisibleByPlayer>();
      BuildSignalsArrayOnComponentAdded<BotSDKGlobals>();
      BuildSignalsArrayOnComponentRemoved<BotSDKGlobals>();
      BuildSignalsArrayOnComponentAdded<Quantum.BotSpawnPoint>();
      BuildSignalsArrayOnComponentRemoved<Quantum.BotSpawnPoint>();
      BuildSignalsArrayOnComponentAdded<CharacterController2D>();
      BuildSignalsArrayOnComponentRemoved<CharacterController2D>();
      BuildSignalsArrayOnComponentAdded<CharacterController3D>();
      BuildSignalsArrayOnComponentRemoved<CharacterController3D>();
      BuildSignalsArrayOnComponentAdded<Quantum.CharacterFsm>();
      BuildSignalsArrayOnComponentRemoved<Quantum.CharacterFsm>();
      BuildSignalsArrayOnComponentAdded<Quantum.CharacterLoadout>();
      BuildSignalsArrayOnComponentRemoved<Quantum.CharacterLoadout>();
      BuildSignalsArrayOnComponentAdded<Quantum.CharacterLoadoutModifiedMarker>();
      BuildSignalsArrayOnComponentRemoved<Quantum.CharacterLoadoutModifiedMarker>();
      BuildSignalsArrayOnComponentAdded<Quantum.CharacterSafe>();
      BuildSignalsArrayOnComponentRemoved<Quantum.CharacterSafe>();
      BuildSignalsArrayOnComponentAdded<Quantum.CharacterSpectatorCamera>();
      BuildSignalsArrayOnComponentRemoved<Quantum.CharacterSpectatorCamera>();
      BuildSignalsArrayOnComponentAdded<Quantum.CharacterStateCrouchIdle>();
      BuildSignalsArrayOnComponentRemoved<Quantum.CharacterStateCrouchIdle>();
      BuildSignalsArrayOnComponentAdded<Quantum.CharacterStateCrouchMove>();
      BuildSignalsArrayOnComponentRemoved<Quantum.CharacterStateCrouchMove>();
      BuildSignalsArrayOnComponentAdded<Quantum.CharacterStateDead>();
      BuildSignalsArrayOnComponentRemoved<Quantum.CharacterStateDead>();
      BuildSignalsArrayOnComponentAdded<Quantum.CharacterStateHealing>();
      BuildSignalsArrayOnComponentRemoved<Quantum.CharacterStateHealing>();
      BuildSignalsArrayOnComponentAdded<Quantum.CharacterStateIdle>();
      BuildSignalsArrayOnComponentRemoved<Quantum.CharacterStateIdle>();
      BuildSignalsArrayOnComponentAdded<Quantum.CharacterStateJump>();
      BuildSignalsArrayOnComponentRemoved<Quantum.CharacterStateJump>();
      BuildSignalsArrayOnComponentAdded<Quantum.CharacterStateKnifeAttack>();
      BuildSignalsArrayOnComponentRemoved<Quantum.CharacterStateKnifeAttack>();
      BuildSignalsArrayOnComponentAdded<Quantum.CharacterStateKnocked>();
      BuildSignalsArrayOnComponentRemoved<Quantum.CharacterStateKnocked>();
      BuildSignalsArrayOnComponentAdded<Quantum.CharacterStateReviving>();
      BuildSignalsArrayOnComponentRemoved<Quantum.CharacterStateReviving>();
      BuildSignalsArrayOnComponentAdded<Quantum.CharacterStateRoll>();
      BuildSignalsArrayOnComponentRemoved<Quantum.CharacterStateRoll>();
      BuildSignalsArrayOnComponentAdded<Quantum.CharacterStateSprint>();
      BuildSignalsArrayOnComponentRemoved<Quantum.CharacterStateSprint>();
      BuildSignalsArrayOnComponentAdded<Quantum.CharacterStateWalk>();
      BuildSignalsArrayOnComponentRemoved<Quantum.CharacterStateWalk>();
      BuildSignalsArrayOnComponentAdded<Quantum.DebugGizmo>();
      BuildSignalsArrayOnComponentRemoved<Quantum.DebugGizmo>();
      BuildSignalsArrayOnComponentAdded<Quantum.DropFromUnitMarker>();
      BuildSignalsArrayOnComponentRemoved<Quantum.DropFromUnitMarker>();
      BuildSignalsArrayOnComponentAdded<Quantum.ExitZone>();
      BuildSignalsArrayOnComponentRemoved<Quantum.ExitZone>();
      BuildSignalsArrayOnComponentAdded<Quantum.FlashbangBlindEffect>();
      BuildSignalsArrayOnComponentRemoved<Quantum.FlashbangBlindEffect>();
      BuildSignalsArrayOnComponentAdded<HFSMAgent>();
      BuildSignalsArrayOnComponentRemoved<HFSMAgent>();
      BuildSignalsArrayOnComponentAdded<Quantum.Health>();
      BuildSignalsArrayOnComponentRemoved<Quantum.Health>();
      BuildSignalsArrayOnComponentAdded<Quantum.InitializeData>();
      BuildSignalsArrayOnComponentRemoved<Quantum.InitializeData>();
      BuildSignalsArrayOnComponentAdded<Quantum.InputContainer>();
      BuildSignalsArrayOnComponentRemoved<Quantum.InputContainer>();
      BuildSignalsArrayOnComponentAdded<Quantum.InsidePersistentAoE>();
      BuildSignalsArrayOnComponentRemoved<Quantum.InsidePersistentAoE>();
      BuildSignalsArrayOnComponentAdded<Quantum.InteractiveZone>();
      BuildSignalsArrayOnComponentRemoved<Quantum.InteractiveZone>();
      BuildSignalsArrayOnComponentAdded<Quantum.InvisibilityZone>();
      BuildSignalsArrayOnComponentRemoved<Quantum.InvisibilityZone>();
      BuildSignalsArrayOnComponentAdded<Quantum.Item>();
      BuildSignalsArrayOnComponentRemoved<Quantum.Item>();
      BuildSignalsArrayOnComponentAdded<Quantum.ItemBox>();
      BuildSignalsArrayOnComponentRemoved<Quantum.ItemBox>();
      BuildSignalsArrayOnComponentAdded<Quantum.ItemBoxKeepAliveWithoutItems>();
      BuildSignalsArrayOnComponentRemoved<Quantum.ItemBoxKeepAliveWithoutItems>();
      BuildSignalsArrayOnComponentAdded<Quantum.ItemBoxSpawnPoint>();
      BuildSignalsArrayOnComponentRemoved<Quantum.ItemBoxSpawnPoint>();
      BuildSignalsArrayOnComponentAdded<Quantum.ItemOutOfUses>();
      BuildSignalsArrayOnComponentRemoved<Quantum.ItemOutOfUses>();
      BuildSignalsArrayOnComponentAdded<Quantum.ItemOwnerIsItemBox>();
      BuildSignalsArrayOnComponentRemoved<Quantum.ItemOwnerIsItemBox>();
      BuildSignalsArrayOnComponentAdded<Quantum.ItemOwnerIsSafe>();
      BuildSignalsArrayOnComponentRemoved<Quantum.ItemOwnerIsSafe>();
      BuildSignalsArrayOnComponentAdded<Quantum.ItemOwnerIsUnit>();
      BuildSignalsArrayOnComponentRemoved<Quantum.ItemOwnerIsUnit>();
      BuildSignalsArrayOnComponentAdded<Quantum.ItemOwnerIsWeapon>();
      BuildSignalsArrayOnComponentRemoved<Quantum.ItemOwnerIsWeapon>();
      BuildSignalsArrayOnComponentAdded<Quantum.KCC>();
      BuildSignalsArrayOnComponentRemoved<Quantum.KCC>();
      BuildSignalsArrayOnComponentAdded<Quantum.KCCProcessorLink>();
      BuildSignalsArrayOnComponentRemoved<Quantum.KCCProcessorLink>();
      BuildSignalsArrayOnComponentAdded<Quantum.LagCompensationProxy>();
      BuildSignalsArrayOnComponentRemoved<Quantum.LagCompensationProxy>();
      BuildSignalsArrayOnComponentAdded<Quantum.LagCompensationTarget>();
      BuildSignalsArrayOnComponentRemoved<Quantum.LagCompensationTarget>();
      BuildSignalsArrayOnComponentAdded<MapEntityLink>();
      BuildSignalsArrayOnComponentRemoved<MapEntityLink>();
      BuildSignalsArrayOnComponentAdded<Quantum.Mine>();
      BuildSignalsArrayOnComponentRemoved<Quantum.Mine>();
      BuildSignalsArrayOnComponentAdded<NavMeshAvoidanceAgent>();
      BuildSignalsArrayOnComponentRemoved<NavMeshAvoidanceAgent>();
      BuildSignalsArrayOnComponentAdded<NavMeshAvoidanceObstacle>();
      BuildSignalsArrayOnComponentRemoved<NavMeshAvoidanceObstacle>();
      BuildSignalsArrayOnComponentAdded<NavMeshPathfinder>();
      BuildSignalsArrayOnComponentRemoved<NavMeshPathfinder>();
      BuildSignalsArrayOnComponentAdded<NavMeshSteeringAgent>();
      BuildSignalsArrayOnComponentRemoved<NavMeshSteeringAgent>();
      BuildSignalsArrayOnComponentAdded<Quantum.NickName>();
      BuildSignalsArrayOnComponentRemoved<Quantum.NickName>();
      BuildSignalsArrayOnComponentAdded<Quantum.ObjectLifetime>();
      BuildSignalsArrayOnComponentRemoved<Quantum.ObjectLifetime>();
      BuildSignalsArrayOnComponentAdded<Quantum.OpenedItemBoxMarker>();
      BuildSignalsArrayOnComponentRemoved<Quantum.OpenedItemBoxMarker>();
      BuildSignalsArrayOnComponentAdded<Quantum.ParentEntityLink>();
      BuildSignalsArrayOnComponentRemoved<Quantum.ParentEntityLink>();
      BuildSignalsArrayOnComponentAdded<Quantum.PerceptionMemory>();
      BuildSignalsArrayOnComponentRemoved<Quantum.PerceptionMemory>();
      BuildSignalsArrayOnComponentAdded<PhysicsBody2D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsBody2D>();
      BuildSignalsArrayOnComponentAdded<PhysicsBody3D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsBody3D>();
      BuildSignalsArrayOnComponentAdded<PhysicsCallbacks2D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsCallbacks2D>();
      BuildSignalsArrayOnComponentAdded<PhysicsCallbacks3D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsCallbacks3D>();
      BuildSignalsArrayOnComponentAdded<PhysicsCollider2D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsCollider2D>();
      BuildSignalsArrayOnComponentAdded<PhysicsCollider3D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsCollider3D>();
      BuildSignalsArrayOnComponentAdded<PhysicsJoints2D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsJoints2D>();
      BuildSignalsArrayOnComponentAdded<PhysicsJoints3D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsJoints3D>();
      BuildSignalsArrayOnComponentAdded<Quantum.PingPongTarget>();
      BuildSignalsArrayOnComponentRemoved<Quantum.PingPongTarget>();
      BuildSignalsArrayOnComponentAdded<Quantum.ReconEffect>();
      BuildSignalsArrayOnComponentRemoved<Quantum.ReconEffect>();
      BuildSignalsArrayOnComponentAdded<Quantum.SlowDebuff>();
      BuildSignalsArrayOnComponentRemoved<Quantum.SlowDebuff>();
      BuildSignalsArrayOnComponentAdded<Quantum.SpawnPoint>();
      BuildSignalsArrayOnComponentRemoved<Quantum.SpawnPoint>();
      BuildSignalsArrayOnComponentAdded<Quantum.Team>();
      BuildSignalsArrayOnComponentRemoved<Quantum.Team>();
      BuildSignalsArrayOnComponentAdded<Quantum.TimerItemBoxMarker>();
      BuildSignalsArrayOnComponentRemoved<Quantum.TimerItemBoxMarker>();
      BuildSignalsArrayOnComponentAdded<Transform2D>();
      BuildSignalsArrayOnComponentRemoved<Transform2D>();
      BuildSignalsArrayOnComponentAdded<Transform2DVertical>();
      BuildSignalsArrayOnComponentRemoved<Transform2DVertical>();
      BuildSignalsArrayOnComponentAdded<Transform3D>();
      BuildSignalsArrayOnComponentRemoved<Transform3D>();
      BuildSignalsArrayOnComponentAdded<Quantum.TriggerArea>();
      BuildSignalsArrayOnComponentRemoved<Quantum.TriggerArea>();
      BuildSignalsArrayOnComponentAdded<Quantum.TriggerAreaWithEntities>();
      BuildSignalsArrayOnComponentRemoved<Quantum.TriggerAreaWithEntities>();
      BuildSignalsArrayOnComponentAdded<Quantum.Turret>();
      BuildSignalsArrayOnComponentRemoved<Quantum.Turret>();
      BuildSignalsArrayOnComponentAdded<UTAgent>();
      BuildSignalsArrayOnComponentRemoved<UTAgent>();
      BuildSignalsArrayOnComponentAdded<Quantum.Unit>();
      BuildSignalsArrayOnComponentRemoved<Quantum.Unit>();
      BuildSignalsArrayOnComponentAdded<Quantum.UnitAim>();
      BuildSignalsArrayOnComponentRemoved<Quantum.UnitAim>();
      BuildSignalsArrayOnComponentAdded<Quantum.UnitDestroyOnDead>();
      BuildSignalsArrayOnComponentRemoved<Quantum.UnitDestroyOnDead>();
      BuildSignalsArrayOnComponentAdded<Quantum.UnitExited>();
      BuildSignalsArrayOnComponentRemoved<Quantum.UnitExited>();
      BuildSignalsArrayOnComponentAdded<Quantum.UnitFeatureDropLoadoutOnDeath>();
      BuildSignalsArrayOnComponentRemoved<Quantum.UnitFeatureDropLoadoutOnDeath>();
      BuildSignalsArrayOnComponentAdded<Quantum.UnitFeatureHealSelfOnDeath>();
      BuildSignalsArrayOnComponentRemoved<Quantum.UnitFeatureHealSelfOnDeath>();
      BuildSignalsArrayOnComponentAdded<Quantum.UnitFeatureSprintWithStamina>();
      BuildSignalsArrayOnComponentRemoved<Quantum.UnitFeatureSprintWithStamina>();
      BuildSignalsArrayOnComponentAdded<View>();
      BuildSignalsArrayOnComponentRemoved<View>();
      BuildSignalsArrayOnComponentAdded<Quantum.Vision>();
      BuildSignalsArrayOnComponentRemoved<Quantum.Vision>();
      BuildSignalsArrayOnComponentAdded<Quantum.Way>();
      BuildSignalsArrayOnComponentRemoved<Quantum.Way>();
      BuildSignalsArrayOnComponentAdded<Quantum.Weapon>();
      BuildSignalsArrayOnComponentRemoved<Quantum.Weapon>();
      BuildSignalsArrayOnComponentAdded<Quantum.WeaponAttack>();
      BuildSignalsArrayOnComponentRemoved<Quantum.WeaponAttack>();
      BuildSignalsArrayOnComponentAdded<Quantum.WeaponItem>();
      BuildSignalsArrayOnComponentRemoved<Quantum.WeaponItem>();
    }
    partial void SetPlayerInputCodeGen(PlayerRef player, Input input) {
      if ((int)player >= (int)_globals->input.Length) { throw new System.ArgumentOutOfRangeException("player"); }
      var i = _globals->input.GetPointer(player);
      i->MovementMagnitudeEncoded = input.MovementMagnitudeEncoded;
      i->MovementDirectionEncoded = input.MovementDirectionEncoded;
      i->InterpolationOffset = input.InterpolationOffset;
      i->InterpolationAlphaEncoded = input.InterpolationAlphaEncoded;
      i->LookRotationDelta = input.LookRotationDelta;
      i->LookRotation = input.LookRotation;
      i->AimTarget = input.AimTarget;
      i->SecondaryAction = i->SecondaryAction.Update(this.Number, input.SecondaryAction);
      i->AimButton = i->AimButton.Update(this.Number, input.AimButton);
      i->SprintButton = i->SprintButton.Update(this.Number, input.SprintButton);
    }
    public Input* GetPlayerInput(PlayerRef player) {
      if ((int)player >= (int)_globals->input.Length) { throw new System.ArgumentOutOfRangeException("player"); }
      return _globals->input.GetPointer(player);
    }
    partial void GetPlayerLastConnectionStateCodeGen(ref BitSetRef bitSet) {
      bitSet = new(_globals->PlayerLastConnectionState.Bits, _globals->PlayerLastConnectionState.Length);
    }
    partial void ResetPhysicsCodeGen() {
      Physics2D?.Init(_globals->PhysicsState2D.MapStaticCollidersState.TrackedMap);
      Physics3D?.Init(_globals->PhysicsState3D.MapStaticCollidersState.TrackedMap);
    }
    public unsafe partial struct FrameSignals {
      public void OnCooldownsReset(EntityRef playerEntityRef) {
        var array = _f._ISignalOnCooldownsResetSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnCooldownsReset(_f, playerEntityRef);
          }
        }
      }
      public void OnActiveAbilityStopped(EntityRef playerEntityRef) {
        var array = _f._ISignalOnActiveAbilityStoppedSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnActiveAbilityStopped(_f, playerEntityRef);
          }
        }
      }
      public void OnCreateAttack(EntityRef attackEntity, Attack* attack) {
        var array = _f._ISignalOnCreateAttackSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnCreateAttack(_f, attackEntity, attack);
          }
        }
      }
      public void OnDisableAttack(EntityRef attackEntity) {
        var array = _f._ISignalOnDisableAttackSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnDisableAttack(_f, attackEntity);
          }
        }
      }
      public void OnCharacterBeforeLoadoutSlotUnassigned(EntityRef characterEntity, CharacterLoadoutSlots slot, EntityRef itemEntity) {
        var array = _f._ISignalOnCharacterBeforeLoadoutSlotUnassignedSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnCharacterBeforeLoadoutSlotUnassigned(_f, characterEntity, slot, itemEntity);
          }
        }
      }
      public void OnCharacterAfterLoadoutSlotAssigned(EntityRef characterEntity, CharacterLoadoutSlots slot, EntityRef itemEntity) {
        var array = _f._ISignalOnCharacterAfterLoadoutSlotAssignedSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnCharacterAfterLoadoutSlotAssigned(_f, characterEntity, slot, itemEntity);
          }
        }
      }
      public void OnSafeChanged(EntityRef owner, SafeChangeKind change, EntityRef itemEntity) {
        var array = _f._ISignalOnSafeChangedSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnSafeChanged(_f, owner, change, itemEntity);
          }
        }
      }
      public void OnSafeResized(EntityRef owner, Int32 width, Int32 height) {
        var array = _f._ISignalOnSafeResizedSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnSafeResized(_f, owner, width, height);
          }
        }
      }
      public void OnExitZoneUsed(Int32 photonActorId) {
        var array = _f._ISignalOnExitZoneUsedSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnExitZoneUsed(_f, photonActorId);
          }
        }
      }
      public void OnPresentationStart() {
        var array = _f._ISignalOnPresentationStartSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnPresentationStart(_f);
          }
        }
      }
      public void OnGameStart() {
        var array = _f._ISignalOnGameStartSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnGameStart(_f);
          }
        }
      }
      public void OnGameEnd() {
        var array = _f._ISignalOnGameEndSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnGameEnd(_f);
          }
        }
      }
      public void OnOpenItemBox(EntityRef itemBoxRef) {
        var array = _f._ISignalOnOpenItemBoxSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnOpenItemBox(_f, itemBoxRef);
          }
        }
      }
      public void OnMineTrigger(EntityRef mineRef) {
        var array = _f._ISignalOnMineTriggerSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnMineTrigger(_f, mineRef);
          }
        }
      }
      public void OnUnitSpawn(EntityRef e) {
        var array = _f._ISignalOnUnitSpawnSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnUnitSpawn(_f, e);
          }
        }
      }
      public void OnUnitDead(EntityRef e) {
        var array = _f._ISignalOnUnitDeadSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnUnitDead(_f, e);
          }
        }
      }
      public void OnUnitDamage(EntityRef source, EntityRef target, FP value) {
        var array = _f._ISignalOnUnitDamageSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnUnitDamage(_f, source, target, value);
          }
        }
      }
      public void OnUnitHeal(EntityRef source, EntityRef target, FP value) {
        var array = _f._ISignalOnUnitHealSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnUnitHeal(_f, source, target, value);
          }
        }
      }
      public void OnUnitHideWeapon(EntityRef unitRef) {
        var array = _f._ISignalOnUnitHideWeaponSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnUnitHideWeapon(_f, unitRef);
          }
        }
      }
      public void OnUnitGetWeapon(EntityRef unitRef) {
        var array = _f._ISignalOnUnitGetWeaponSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnUnitGetWeapon(_f, unitRef);
          }
        }
      }
      public void OnEquipWeapon(EntityRef e) {
        var array = _f._ISignalOnEquipWeaponSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnEquipWeapon(_f, e);
          }
        }
      }
      public void OnReloading(EntityRef attackerRef, EntityRef weaponRef) {
        var array = _f._ISignalOnReloadingSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnReloading(_f, attackerRef, weaponRef);
          }
        }
      }
      public void OnCreateShoot(EntityRef unitRef, EntityRef weaponRef, Weapon* weapon) {
        var array = _f._ISignalOnCreateShootSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnCreateShoot(_f, unitRef, weaponRef, weapon);
          }
        }
      }
    }
  }
  public unsafe partial class Statics {
    public static FrameSerializer.Delegate SerializeAttributeModifier;
    public static FrameSerializer.Delegate SerializeEAttributeType;
    public static FrameSerializer.Delegate SerializeAttributeData;
    public static FrameSerializer.Delegate SerializeEntityRef;
    public static FrameSerializer.Delegate SerializeQGuid;
    public static FrameSerializer.Delegate SerializeHealthAttributeModifier;
    public static FrameSerializer.Delegate SerializeAssetRef;
    public static FrameSerializer.Delegate SerializeKCCCollision;
    public static FrameSerializer.Delegate SerializeKCCIgnore;
    public static FrameSerializer.Delegate SerializeKCCModifier;
    public static FrameSerializer.Delegate SerializeTransform3D;
    public static FrameSerializer.Delegate SerializePerceptionMemoryEntry;
    public static FrameSerializer.Delegate SerializeFPVector3;
    public static FrameSerializer.Delegate SerializeTeamData;
    public static FrameSerializer.Delegate SerializeInt32;
    public static FrameSerializer.Delegate SerializeGlobalVisibilityData;
    public static FrameSerializer.Delegate SerializeWay;
    public static FrameSerializer.Delegate SerializeInput;
    static partial void InitStaticDelegatesGen() {
      SerializeAttributeModifier = Quantum.AttributeModifier.Serialize;
      SerializeEAttributeType = (v, s) => {{ s.Stream.Serialize((Byte*)v); }};
      SerializeAttributeData = Quantum.AttributeData.Serialize;
      SerializeEntityRef = EntityRef.Serialize;
      SerializeQGuid = QGuid.Serialize;
      SerializeHealthAttributeModifier = Quantum.HealthAttributeModifier.Serialize;
      SerializeAssetRef = AssetRef.Serialize;
      SerializeKCCCollision = Quantum.KCCCollision.Serialize;
      SerializeKCCIgnore = Quantum.KCCIgnore.Serialize;
      SerializeKCCModifier = Quantum.KCCModifier.Serialize;
      SerializeTransform3D = Transform3D.Serialize;
      SerializePerceptionMemoryEntry = Quantum.PerceptionMemoryEntry.Serialize;
      SerializeFPVector3 = FPVector3.Serialize;
      SerializeTeamData = Quantum.TeamData.Serialize;
      SerializeInt32 = (v, s) => {{ s.Stream.Serialize((Int32*)v); }};
      SerializeGlobalVisibilityData = Quantum.GlobalVisibilityData.Serialize;
      SerializeWay = Quantum.Way.Serialize;
      SerializeInput = Quantum.Input.Serialize;
    }
    static partial void RegisterSimulationTypesGen(TypeRegistry typeRegistry) {
      typeRegistry.Register(typeof(AIBlackboardComponent), AIBlackboardComponent.SIZE);
      typeRegistry.Register(typeof(Quantum.Ability), Quantum.Ability.SIZE);
      typeRegistry.Register(typeof(Quantum.AbilityAvailabilityType), 4);
      typeRegistry.Register(typeof(Quantum.ActiveAbilityInfo), Quantum.ActiveAbilityInfo.SIZE);
      typeRegistry.Register(typeof(AmmoTypes), 1);
      typeRegistry.Register(typeof(Quantum.AnimationTriggers), Quantum.AnimationTriggers.SIZE);
      typeRegistry.Register(typeof(AssetGuid), AssetGuid.SIZE);
      typeRegistry.Register(typeof(AssetRef), AssetRef.SIZE);
      typeRegistry.Register(typeof(Quantum.Attack), Quantum.Attack.SIZE);
      typeRegistry.Register(typeof(Quantum.AttributeData), Quantum.AttributeData.SIZE);
      typeRegistry.Register(typeof(Quantum.AttributeModifier), Quantum.AttributeModifier.SIZE);
      typeRegistry.Register(typeof(Quantum.Attributes), Quantum.Attributes.SIZE);
      typeRegistry.Register(typeof(Quantum.AttributesTickable), Quantum.AttributesTickable.SIZE);
      typeRegistry.Register(typeof(BTAgent), BTAgent.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet1024), Quantum.BitSet1024.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet128), Quantum.BitSet128.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet2048), Quantum.BitSet2048.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet256), Quantum.BitSet256.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet4096), Quantum.BitSet4096.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet512), Quantum.BitSet512.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet6), Quantum.BitSet6.SIZE);
      typeRegistry.Register(typeof(Quantum.Bot), Quantum.Bot.SIZE);
      typeRegistry.Register(typeof(Quantum.BotIntent), Quantum.BotIntent.SIZE);
      typeRegistry.Register(typeof(Quantum.BotInvisibleByPlayer), Quantum.BotInvisibleByPlayer.SIZE);
      typeRegistry.Register(typeof(BotSDKGlobals), BotSDKGlobals.SIZE);
      typeRegistry.Register(typeof(Quantum.BotSpawnPoint), Quantum.BotSpawnPoint.SIZE);
      typeRegistry.Register(typeof(Button), Button.SIZE);
      typeRegistry.Register(typeof(CallbackFlags), 4);
      typeRegistry.Register(typeof(CharacterController2D), CharacterController2D.SIZE);
      typeRegistry.Register(typeof(CharacterController3D), CharacterController3D.SIZE);
      typeRegistry.Register(typeof(Quantum.CharacterFsm), Quantum.CharacterFsm.SIZE);
      typeRegistry.Register(typeof(Quantum.CharacterLoadout), Quantum.CharacterLoadout.SIZE);
      typeRegistry.Register(typeof(Quantum.CharacterLoadoutModifiedMarker), Quantum.CharacterLoadoutModifiedMarker.SIZE);
      typeRegistry.Register(typeof(CharacterLoadoutSlots), 4);
      typeRegistry.Register(typeof(Quantum.CharacterSafe), Quantum.CharacterSafe.SIZE);
      typeRegistry.Register(typeof(Quantum.CharacterSpectatorCamera), Quantum.CharacterSpectatorCamera.SIZE);
      typeRegistry.Register(typeof(Quantum.CharacterStateCrouchIdle), Quantum.CharacterStateCrouchIdle.SIZE);
      typeRegistry.Register(typeof(Quantum.CharacterStateCrouchMove), Quantum.CharacterStateCrouchMove.SIZE);
      typeRegistry.Register(typeof(Quantum.CharacterStateDead), Quantum.CharacterStateDead.SIZE);
      typeRegistry.Register(typeof(Quantum.CharacterStateHealing), Quantum.CharacterStateHealing.SIZE);
      typeRegistry.Register(typeof(Quantum.CharacterStateIdle), Quantum.CharacterStateIdle.SIZE);
      typeRegistry.Register(typeof(Quantum.CharacterStateJump), Quantum.CharacterStateJump.SIZE);
      typeRegistry.Register(typeof(Quantum.CharacterStateKnifeAttack), Quantum.CharacterStateKnifeAttack.SIZE);
      typeRegistry.Register(typeof(Quantum.CharacterStateKnocked), Quantum.CharacterStateKnocked.SIZE);
      typeRegistry.Register(typeof(Quantum.CharacterStateReviving), Quantum.CharacterStateReviving.SIZE);
      typeRegistry.Register(typeof(Quantum.CharacterStateRoll), Quantum.CharacterStateRoll.SIZE);
      typeRegistry.Register(typeof(Quantum.CharacterStateSprint), Quantum.CharacterStateSprint.SIZE);
      typeRegistry.Register(typeof(Quantum.CharacterStateWalk), Quantum.CharacterStateWalk.SIZE);
      typeRegistry.Register(typeof(Quantum.CharacterStates), 4);
      typeRegistry.Register(typeof(Quantum.CircleData), Quantum.CircleData.SIZE);
      typeRegistry.Register(typeof(ColorRGBA), ColorRGBA.SIZE);
      typeRegistry.Register(typeof(ComponentPrototypeRef), ComponentPrototypeRef.SIZE);
      typeRegistry.Register(typeof(ComponentTypeRef), ComponentTypeRef.SIZE);
      typeRegistry.Register(typeof(Quantum.CountdownTimer), Quantum.CountdownTimer.SIZE);
      typeRegistry.Register(typeof(Quantum.DebugGizmo), Quantum.DebugGizmo.SIZE);
      typeRegistry.Register(typeof(DistanceJoint), DistanceJoint.SIZE);
      typeRegistry.Register(typeof(DistanceJoint3D), DistanceJoint3D.SIZE);
      typeRegistry.Register(typeof(Quantum.DropFromUnitMarker), Quantum.DropFromUnitMarker.SIZE);
      typeRegistry.Register(typeof(Quantum.EAttributeType), 1);
      typeRegistry.Register(typeof(Quantum.EDamageType), 1);
      typeRegistry.Register(typeof(Quantum.EGameStates), 4);
      typeRegistry.Register(typeof(Quantum.EKCCCollisionSource), 1);
      typeRegistry.Register(typeof(Quantum.EKCCIgnoreSource), 1);
      typeRegistry.Register(typeof(Quantum.EKCCProcessorSource), 1);
      typeRegistry.Register(typeof(Quantum.EModifierAppliance), 1);
      typeRegistry.Register(typeof(Quantum.EModifierOperation), 1);
      typeRegistry.Register(typeof(EntityPrototypeRef), EntityPrototypeRef.SIZE);
      typeRegistry.Register(typeof(EntityRef), EntityRef.SIZE);
      typeRegistry.Register(typeof(Quantum.ExitZone), Quantum.ExitZone.SIZE);
      typeRegistry.Register(typeof(FP), FP.SIZE);
      typeRegistry.Register(typeof(Quantum.FPBoostedMultiplier), Quantum.FPBoostedMultiplier.SIZE);
      typeRegistry.Register(typeof(Quantum.FPBoostedValue), Quantum.FPBoostedValue.SIZE);
      typeRegistry.Register(typeof(FPBounds2), FPBounds2.SIZE);
      typeRegistry.Register(typeof(FPBounds3), FPBounds3.SIZE);
      typeRegistry.Register(typeof(FPMatrix2x2), FPMatrix2x2.SIZE);
      typeRegistry.Register(typeof(FPMatrix3x3), FPMatrix3x3.SIZE);
      typeRegistry.Register(typeof(FPMatrix4x4), FPMatrix4x4.SIZE);
      typeRegistry.Register(typeof(FPQuaternion), FPQuaternion.SIZE);
      typeRegistry.Register(typeof(FPVector2), FPVector2.SIZE);
      typeRegistry.Register(typeof(FPVector3), FPVector3.SIZE);
      typeRegistry.Register(typeof(Quantum.FPYawPitchRoll), Quantum.FPYawPitchRoll.SIZE);
      typeRegistry.Register(typeof(Quantum.FlashbangBlindEffect), Quantum.FlashbangBlindEffect.SIZE);
      typeRegistry.Register(typeof(FrameMetaData), FrameMetaData.SIZE);
      typeRegistry.Register(typeof(FrameTimer), FrameTimer.SIZE);
      typeRegistry.Register(typeof(Quantum.GlobalVisibilityData), Quantum.GlobalVisibilityData.SIZE);
      typeRegistry.Register(typeof(HFSMAgent), HFSMAgent.SIZE);
      typeRegistry.Register(typeof(HFSMData), HFSMData.SIZE);
      typeRegistry.Register(typeof(Quantum.Health), Quantum.Health.SIZE);
      typeRegistry.Register(typeof(Quantum.HealthApplicator), Quantum.HealthApplicator.SIZE);
      typeRegistry.Register(typeof(Quantum.HealthAttributeAppliance), 1);
      typeRegistry.Register(typeof(Quantum.HealthAttributeModifier), Quantum.HealthAttributeModifier.SIZE);
      typeRegistry.Register(typeof(Quantum.HealthAttributeOperation), 1);
      typeRegistry.Register(typeof(HingeJoint), HingeJoint.SIZE);
      typeRegistry.Register(typeof(HingeJoint3D), HingeJoint3D.SIZE);
      typeRegistry.Register(typeof(Hit), Hit.SIZE);
      typeRegistry.Register(typeof(Hit3D), Hit3D.SIZE);
      typeRegistry.Register(typeof(Quantum.InitializeData), Quantum.InitializeData.SIZE);
      typeRegistry.Register(typeof(Quantum.Input), Quantum.Input.SIZE);
      typeRegistry.Register(typeof(Quantum.InputButtons), 4);
      typeRegistry.Register(typeof(Quantum.InputContainer), Quantum.InputContainer.SIZE);
      typeRegistry.Register(typeof(InputDirection), InputDirection.SIZE);
      typeRegistry.Register(typeof(InputDirectionMagnitude), InputDirectionMagnitude.SIZE);
      typeRegistry.Register(typeof(InputPitchYaw), InputPitchYaw.SIZE);
      typeRegistry.Register(typeof(Quantum.InsidePersistentAoE), Quantum.InsidePersistentAoE.SIZE);
      typeRegistry.Register(typeof(IntVector2), IntVector2.SIZE);
      typeRegistry.Register(typeof(IntVector3), IntVector3.SIZE);
      typeRegistry.Register(typeof(Quantum.InteractiveZone), Quantum.InteractiveZone.SIZE);
      typeRegistry.Register(typeof(Quantum.InvisibilityZone), Quantum.InvisibilityZone.SIZE);
      typeRegistry.Register(typeof(Quantum.Item), Quantum.Item.SIZE);
      typeRegistry.Register(typeof(Quantum.ItemBox), Quantum.ItemBox.SIZE);
      typeRegistry.Register(typeof(Quantum.ItemBoxKeepAliveWithoutItems), Quantum.ItemBoxKeepAliveWithoutItems.SIZE);
      typeRegistry.Register(typeof(Quantum.ItemBoxSpawnPoint), Quantum.ItemBoxSpawnPoint.SIZE);
      typeRegistry.Register(typeof(Quantum.ItemOutOfUses), Quantum.ItemOutOfUses.SIZE);
      typeRegistry.Register(typeof(Quantum.ItemOwnerIsItemBox), Quantum.ItemOwnerIsItemBox.SIZE);
      typeRegistry.Register(typeof(Quantum.ItemOwnerIsSafe), Quantum.ItemOwnerIsSafe.SIZE);
      typeRegistry.Register(typeof(Quantum.ItemOwnerIsUnit), Quantum.ItemOwnerIsUnit.SIZE);
      typeRegistry.Register(typeof(Quantum.ItemOwnerIsWeapon), Quantum.ItemOwnerIsWeapon.SIZE);
      typeRegistry.Register(typeof(Joint), Joint.SIZE);
      typeRegistry.Register(typeof(Joint3D), Joint3D.SIZE);
      typeRegistry.Register(typeof(Quantum.KCC), Quantum.KCC.SIZE);
      typeRegistry.Register(typeof(Quantum.KCCCollision), Quantum.KCCCollision.SIZE);
      typeRegistry.Register(typeof(Quantum.KCCData), Quantum.KCCData.SIZE);
      typeRegistry.Register(typeof(Quantum.KCCIgnore), Quantum.KCCIgnore.SIZE);
      typeRegistry.Register(typeof(Quantum.KCCModifier), Quantum.KCCModifier.SIZE);
      typeRegistry.Register(typeof(Quantum.KCCProcessorLink), Quantum.KCCProcessorLink.SIZE);
      typeRegistry.Register(typeof(Quantum.LagCompensationProxy), Quantum.LagCompensationProxy.SIZE);
      typeRegistry.Register(typeof(Quantum.LagCompensationTarget), Quantum.LagCompensationTarget.SIZE);
      typeRegistry.Register(typeof(LayerMask), LayerMask.SIZE);
      typeRegistry.Register(typeof(Quantum.LineData), Quantum.LineData.SIZE);
      typeRegistry.Register(typeof(MapEntityId), MapEntityId.SIZE);
      typeRegistry.Register(typeof(MapEntityLink), MapEntityLink.SIZE);
      typeRegistry.Register(typeof(Quantum.Mine), Quantum.Mine.SIZE);
      typeRegistry.Register(typeof(NavMeshAvoidanceAgent), NavMeshAvoidanceAgent.SIZE);
      typeRegistry.Register(typeof(NavMeshAvoidanceObstacle), NavMeshAvoidanceObstacle.SIZE);
      typeRegistry.Register(typeof(NavMeshPathfinder), NavMeshPathfinder.SIZE);
      typeRegistry.Register(typeof(NavMeshRegionMask), NavMeshRegionMask.SIZE);
      typeRegistry.Register(typeof(NavMeshSteeringAgent), NavMeshSteeringAgent.SIZE);
      typeRegistry.Register(typeof(Quantum.NickName), Quantum.NickName.SIZE);
      typeRegistry.Register(typeof(NullableFP), NullableFP.SIZE);
      typeRegistry.Register(typeof(NullableFPVector2), NullableFPVector2.SIZE);
      typeRegistry.Register(typeof(NullableFPVector3), NullableFPVector3.SIZE);
      typeRegistry.Register(typeof(NullableNonNegativeFP), NullableNonNegativeFP.SIZE);
      typeRegistry.Register(typeof(Quantum.ObjectLifetime), Quantum.ObjectLifetime.SIZE);
      typeRegistry.Register(typeof(Quantum.OpenedItemBoxMarker), Quantum.OpenedItemBoxMarker.SIZE);
      typeRegistry.Register(typeof(Quantum.ParentEntityLink), Quantum.ParentEntityLink.SIZE);
      typeRegistry.Register(typeof(Quantum.PerceptionMemory), Quantum.PerceptionMemory.SIZE);
      typeRegistry.Register(typeof(Quantum.PerceptionMemoryEntry), Quantum.PerceptionMemoryEntry.SIZE);
      typeRegistry.Register(typeof(Quantum.PerceptionType), 4);
      typeRegistry.Register(typeof(PhysicsBody2D), PhysicsBody2D.SIZE);
      typeRegistry.Register(typeof(PhysicsBody3D), PhysicsBody3D.SIZE);
      typeRegistry.Register(typeof(PhysicsCallbacks2D), PhysicsCallbacks2D.SIZE);
      typeRegistry.Register(typeof(PhysicsCallbacks3D), PhysicsCallbacks3D.SIZE);
      typeRegistry.Register(typeof(PhysicsCollider2D), PhysicsCollider2D.SIZE);
      typeRegistry.Register(typeof(PhysicsCollider3D), PhysicsCollider3D.SIZE);
      typeRegistry.Register(typeof(PhysicsEngineState), PhysicsEngineState.SIZE);
      typeRegistry.Register(typeof(PhysicsJoints2D), PhysicsJoints2D.SIZE);
      typeRegistry.Register(typeof(PhysicsJoints3D), PhysicsJoints3D.SIZE);
      typeRegistry.Register(typeof(PhysicsQueryRef), PhysicsQueryRef.SIZE);
      typeRegistry.Register(typeof(PhysicsSceneSettings), PhysicsSceneSettings.SIZE);
      typeRegistry.Register(typeof(Quantum.PingPongTarget), Quantum.PingPongTarget.SIZE);
      typeRegistry.Register(typeof(PlayerRef), PlayerRef.SIZE);
      typeRegistry.Register(typeof(Ptr), Ptr.SIZE);
      typeRegistry.Register(typeof(QBoolean), QBoolean.SIZE);
      typeRegistry.Register(typeof(QGuid), QGuid.SIZE);
      typeRegistry.Register(typeof(Quantum.QString32), Quantum.QString32.SIZE);
      typeRegistry.Register(typeof(Quantum.Ptr), Quantum.Ptr.SIZE);
      typeRegistry.Register(typeof(QueryOptions), 2);
      typeRegistry.Register(typeof(RNGSession), RNGSession.SIZE);
      typeRegistry.Register(typeof(Quantum.RayData), Quantum.RayData.SIZE);
      typeRegistry.Register(typeof(Quantum.ReconEffect), Quantum.ReconEffect.SIZE);
      typeRegistry.Register(typeof(Quantum.SafeChangeKind), 4);
      typeRegistry.Register(typeof(Shape2D), Shape2D.SIZE);
      typeRegistry.Register(typeof(Shape3D), Shape3D.SIZE);
      typeRegistry.Register(typeof(Quantum.SlowDebuff), Quantum.SlowDebuff.SIZE);
      typeRegistry.Register(typeof(Quantum.SpawnPoint), Quantum.SpawnPoint.SIZE);
      typeRegistry.Register(typeof(SpringJoint), SpringJoint.SIZE);
      typeRegistry.Register(typeof(SpringJoint3D), SpringJoint3D.SIZE);
      typeRegistry.Register(typeof(Quantum.Team), Quantum.Team.SIZE);
      typeRegistry.Register(typeof(Quantum.TeamData), Quantum.TeamData.SIZE);
      typeRegistry.Register(typeof(Quantum.TimerItemBoxMarker), Quantum.TimerItemBoxMarker.SIZE);
      typeRegistry.Register(typeof(Transform2D), Transform2D.SIZE);
      typeRegistry.Register(typeof(Transform2DVertical), Transform2DVertical.SIZE);
      typeRegistry.Register(typeof(Transform3D), Transform3D.SIZE);
      typeRegistry.Register(typeof(Quantum.TriggerArea), Quantum.TriggerArea.SIZE);
      typeRegistry.Register(typeof(Quantum.TriggerAreaWithEntities), Quantum.TriggerAreaWithEntities.SIZE);
      typeRegistry.Register(typeof(Quantum.Turret), Quantum.Turret.SIZE);
      typeRegistry.Register(typeof(UTAgent), UTAgent.SIZE);
      typeRegistry.Register(typeof(Quantum.UnionDrawData), Quantum.UnionDrawData.SIZE);
      typeRegistry.Register(typeof(Quantum.Unit), Quantum.Unit.SIZE);
      typeRegistry.Register(typeof(Quantum.UnitAim), Quantum.UnitAim.SIZE);
      typeRegistry.Register(typeof(Quantum.UnitDestroyOnDead), Quantum.UnitDestroyOnDead.SIZE);
      typeRegistry.Register(typeof(Quantum.UnitExited), Quantum.UnitExited.SIZE);
      typeRegistry.Register(typeof(Quantum.UnitFeatureDropLoadoutOnDeath), Quantum.UnitFeatureDropLoadoutOnDeath.SIZE);
      typeRegistry.Register(typeof(Quantum.UnitFeatureHealSelfOnDeath), Quantum.UnitFeatureHealSelfOnDeath.SIZE);
      typeRegistry.Register(typeof(Quantum.UnitFeatureSprintWithStamina), Quantum.UnitFeatureSprintWithStamina.SIZE);
      typeRegistry.Register(typeof(Quantum.UnitStats), Quantum.UnitStats.SIZE);
      typeRegistry.Register(typeof(View), View.SIZE);
      typeRegistry.Register(typeof(Quantum.VisibilityArea), Quantum.VisibilityArea.SIZE);
      typeRegistry.Register(typeof(Quantum.Vision), Quantum.Vision.SIZE);
      typeRegistry.Register(typeof(Quantum.Way), Quantum.Way.SIZE);
      typeRegistry.Register(typeof(Quantum.Weapon), Quantum.Weapon.SIZE);
      typeRegistry.Register(typeof(WeaponAttachmentSlots), 4);
      typeRegistry.Register(typeof(Quantum.WeaponAttack), Quantum.WeaponAttack.SIZE);
      typeRegistry.Register(typeof(Quantum.WeaponItem), Quantum.WeaponItem.SIZE);
      typeRegistry.Register(typeof(Quantum.WeaponSlot), 4);
      typeRegistry.Register(typeof(Quantum.WeaponStats), Quantum.WeaponStats.SIZE);
      typeRegistry.Register(typeof(Quantum._globals_), Quantum._globals_.SIZE);
    }
    static partial void InitComponentTypeIdGen() {
      ComponentTypeId.Reset(ComponentTypeId.BuiltInComponentCount + 80)
        .AddBuiltInComponents()
        .Add<AIBlackboardComponent>(AIBlackboardComponent.Serialize, AIBlackboardComponent.OnAdded, AIBlackboardComponent.OnRemoved, ComponentFlags.None)
        .Add<Quantum.Ability>(Quantum.Ability.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.AnimationTriggers>(Quantum.AnimationTriggers.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.Attack>(Quantum.Attack.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.Attributes>(Quantum.Attributes.Serialize, Quantum.Attributes.OnAdded, Quantum.Attributes.OnRemoved, ComponentFlags.None)
        .Add<Quantum.AttributesTickable>(Quantum.AttributesTickable.Serialize, null, null, ComponentFlags.None)
        .Add<BTAgent>(BTAgent.Serialize, BTAgent.OnAdded, BTAgent.OnRemoved, ComponentFlags.None)
        .Add<Quantum.Bot>(Quantum.Bot.Serialize, Quantum.Bot.OnAdded, Quantum.Bot.OnRemoved, ComponentFlags.None)
        .Add<Quantum.BotInvisibleByPlayer>(Quantum.BotInvisibleByPlayer.Serialize, null, null, ComponentFlags.None)
        .Add<BotSDKGlobals>(BotSDKGlobals.Serialize, BotSDKGlobals.OnAdded, BotSDKGlobals.OnRemoved, ComponentFlags.Singleton)
        .Add<Quantum.BotSpawnPoint>(Quantum.BotSpawnPoint.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.CharacterFsm>(Quantum.CharacterFsm.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.CharacterLoadout>(Quantum.CharacterLoadout.Serialize, Quantum.CharacterLoadout.OnAdded, Quantum.CharacterLoadout.OnRemoved, ComponentFlags.None)
        .Add<Quantum.CharacterLoadoutModifiedMarker>(Quantum.CharacterLoadoutModifiedMarker.Serialize, Quantum.CharacterLoadoutModifiedMarker.OnAdded, Quantum.CharacterLoadoutModifiedMarker.OnRemoved, ComponentFlags.None)
        .Add<Quantum.CharacterSafe>(Quantum.CharacterSafe.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.CharacterSpectatorCamera>(Quantum.CharacterSpectatorCamera.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.CharacterStateCrouchIdle>(Quantum.CharacterStateCrouchIdle.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.CharacterStateCrouchMove>(Quantum.CharacterStateCrouchMove.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.CharacterStateDead>(Quantum.CharacterStateDead.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.CharacterStateHealing>(Quantum.CharacterStateHealing.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.CharacterStateIdle>(Quantum.CharacterStateIdle.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.CharacterStateJump>(Quantum.CharacterStateJump.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.CharacterStateKnifeAttack>(Quantum.CharacterStateKnifeAttack.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.CharacterStateKnocked>(Quantum.CharacterStateKnocked.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.CharacterStateReviving>(Quantum.CharacterStateReviving.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.CharacterStateRoll>(Quantum.CharacterStateRoll.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.CharacterStateSprint>(Quantum.CharacterStateSprint.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.CharacterStateWalk>(Quantum.CharacterStateWalk.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.DebugGizmo>(Quantum.DebugGizmo.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.DropFromUnitMarker>(Quantum.DropFromUnitMarker.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.ExitZone>(Quantum.ExitZone.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.FlashbangBlindEffect>(Quantum.FlashbangBlindEffect.Serialize, null, null, ComponentFlags.None)
        .Add<HFSMAgent>(HFSMAgent.Serialize, HFSMAgent.OnAdded, HFSMAgent.OnRemoved, ComponentFlags.None)
        .Add<Quantum.Health>(Quantum.Health.Serialize, Quantum.Health.OnAdded, Quantum.Health.OnRemoved, ComponentFlags.None)
        .Add<Quantum.InitializeData>(Quantum.InitializeData.Serialize, Quantum.InitializeData.OnAdded, Quantum.InitializeData.OnRemoved, ComponentFlags.Singleton)
        .Add<Quantum.InputContainer>(Quantum.InputContainer.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.InsidePersistentAoE>(Quantum.InsidePersistentAoE.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.InteractiveZone>(Quantum.InteractiveZone.Serialize, Quantum.InteractiveZone.OnAdded, Quantum.InteractiveZone.OnRemoved, ComponentFlags.None)
        .Add<Quantum.InvisibilityZone>(Quantum.InvisibilityZone.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.Item>(Quantum.Item.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.ItemBox>(Quantum.ItemBox.Serialize, Quantum.ItemBox.OnAdded, Quantum.ItemBox.OnRemoved, ComponentFlags.None)
        .Add<Quantum.ItemBoxKeepAliveWithoutItems>(Quantum.ItemBoxKeepAliveWithoutItems.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.ItemBoxSpawnPoint>(Quantum.ItemBoxSpawnPoint.Serialize, null, Quantum.ItemBoxSpawnPoint.OnRemoved, ComponentFlags.None)
        .Add<Quantum.ItemOutOfUses>(Quantum.ItemOutOfUses.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.ItemOwnerIsItemBox>(Quantum.ItemOwnerIsItemBox.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.ItemOwnerIsSafe>(Quantum.ItemOwnerIsSafe.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.ItemOwnerIsUnit>(Quantum.ItemOwnerIsUnit.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.ItemOwnerIsWeapon>(Quantum.ItemOwnerIsWeapon.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.KCC>(Quantum.KCC.Serialize, null, Quantum.KCC.OnRemoved, ComponentFlags.None)
        .Add<Quantum.KCCProcessorLink>(Quantum.KCCProcessorLink.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.LagCompensationProxy>(Quantum.LagCompensationProxy.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.LagCompensationTarget>(Quantum.LagCompensationTarget.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.Mine>(Quantum.Mine.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.NickName>(Quantum.NickName.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.ObjectLifetime>(Quantum.ObjectLifetime.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.OpenedItemBoxMarker>(Quantum.OpenedItemBoxMarker.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.ParentEntityLink>(Quantum.ParentEntityLink.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.PerceptionMemory>(Quantum.PerceptionMemory.Serialize, Quantum.PerceptionMemory.OnAdded, Quantum.PerceptionMemory.OnRemoved, ComponentFlags.None)
        .Add<Quantum.PingPongTarget>(Quantum.PingPongTarget.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.ReconEffect>(Quantum.ReconEffect.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.SlowDebuff>(Quantum.SlowDebuff.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.SpawnPoint>(Quantum.SpawnPoint.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.Team>(Quantum.Team.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.TimerItemBoxMarker>(Quantum.TimerItemBoxMarker.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.TriggerArea>(Quantum.TriggerArea.Serialize, Quantum.TriggerArea.OnAdded, Quantum.TriggerArea.OnRemoved, ComponentFlags.None)
        .Add<Quantum.TriggerAreaWithEntities>(Quantum.TriggerAreaWithEntities.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.Turret>(Quantum.Turret.Serialize, null, null, ComponentFlags.None)
        .Add<UTAgent>(UTAgent.Serialize, UTAgent.OnAdded, UTAgent.OnRemoved, ComponentFlags.None)
        .Add<Quantum.Unit>(Quantum.Unit.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.UnitAim>(Quantum.UnitAim.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.UnitDestroyOnDead>(Quantum.UnitDestroyOnDead.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.UnitExited>(Quantum.UnitExited.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.UnitFeatureDropLoadoutOnDeath>(Quantum.UnitFeatureDropLoadoutOnDeath.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.UnitFeatureHealSelfOnDeath>(Quantum.UnitFeatureHealSelfOnDeath.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.UnitFeatureSprintWithStamina>(Quantum.UnitFeatureSprintWithStamina.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.Vision>(Quantum.Vision.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.Way>(Quantum.Way.Serialize, Quantum.Way.OnAdded, Quantum.Way.OnRemoved, ComponentFlags.None)
        .Add<Quantum.Weapon>(Quantum.Weapon.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.WeaponAttack>(Quantum.WeaponAttack.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.WeaponItem>(Quantum.WeaponItem.Serialize, null, null, ComponentFlags.None)
        .Finish();
    }
    [Preserve()]
    public static void EnsureNotStrippedGen() {
      FramePrinter.EnsureNotStripped();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.AbilityAvailabilityType>();
      FramePrinter.EnsurePrimitiveNotStripped<AmmoTypes>();
      FramePrinter.EnsurePrimitiveNotStripped<CallbackFlags>();
      FramePrinter.EnsurePrimitiveNotStripped<CharacterLoadoutSlots>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.CharacterStates>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.EAttributeType>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.EDamageType>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.EGameStates>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.EKCCCollisionSource>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.EKCCIgnoreSource>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.EKCCProcessorSource>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.EModifierAppliance>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.EModifierOperation>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.HealthAttributeAppliance>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.HealthAttributeOperation>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.InputButtons>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.PerceptionType>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.QString32>();
      FramePrinter.EnsurePrimitiveNotStripped<QueryOptions>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.SafeChangeKind>();
      FramePrinter.EnsurePrimitiveNotStripped<WeaponAttachmentSlots>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.WeaponSlot>();
    }
  }
}
#pragma warning restore 0109
#pragma warning restore 1591
